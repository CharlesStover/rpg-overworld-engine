/***********************************************\
|*                                             *|
|*   Copyright (c) 2011-2012, Charles Stover   *|
|*             All Rights Reserved             *|
|*                                             *|
\***********************************************/

var fileSizeDotPhpSizes = {
	'images/characters/33/pokemon/grandma.gif': 1.27 * 1024,
	'images/characters/33/pokemon/leaf.gif': 2.16 * 1024,
	'images/characters/33/pokemon/red.gif': 2.14 * 1024,
	'images/characters/66/pokemon/grandma.gif': 1.2 * 1024,
	'images/characters/66/pokemon/leaf.gif': 2.03 * 1024,
	'images/characters/66/pokemon/red.gif': 2.09 * 1024,
	'images/characters/75/pokemon/grandma.gif': 1.2 * 1024,
	'images/characters/75/pokemon/leaf.gif': 2.03 * 1024,
	'images/characters/75/pokemon/red.gif': 2.09 * 1024,
	'images/characters/100/pokemon/grandma.gif': 1.18 * 1024,
	'images/characters/100/pokemon/leaf.gif': 2.01 * 1024,
	'images/characters/100/pokemon/red.gif': 2.07 * 1024,
	'images/choice/arrow.gif': 56,
	'images/choice/arrow-selected.gif': 56,
	'images/maps/33/oaks.png': 7.15 * 1024,
	'images/maps/33/pallet.png': 23.8 * 1024,
	'images/maps/33/room1.png': 7.36 * 1024,
	'images/maps/33/room2.png': 8.42 * 1024,
	'images/maps/33/overlays/oaks.png': 905,
	'images/maps/33/overlays/pallet.png': 3.95 * 1024,
	'images/maps/33/overlays/room1.png': 614,
	'images/maps/33/overlays/room2-1.png': 432,
	'images/maps/33/overlays/room2-2.png': 433,
	'images/maps/66/oaks.png': 7.15 * 1024,
	'images/maps/66/pallet.png': 23.8 * 1024,
	'images/maps/66/room1.png': 7.36 * 1024,
	'images/maps/66/room2.png': 8.42 * 1024,
	'images/maps/66/overlays/oaks.png': 905,
	'images/maps/66/overlays/pallet.png': 3.95 * 1024,
	'images/maps/66/overlays/room1.png': 614,
	'images/maps/66/overlays/room2-1.png': 432,
	'images/maps/66/overlays/room2-2.png': 433,
	'images/maps/75/oaks.png': 7.15 * 1024,
	'images/maps/75/pallet.png': 23.8 * 1024,
	'images/maps/75/room1.png': 7.36 * 1024,
	'images/maps/75/room2.png': 8.42 * 1024,
	'images/maps/75/overlays/oaks.png': 905,
	'images/maps/75/overlays/pallet.png': 3.95 * 1024,
	'images/maps/75/overlays/room1.png': 614,
	'images/maps/75/overlays/room2-1.png': 432,
	'images/maps/75/overlays/room2-2.png': 433,
	'images/maps/100/oaks.png': 7.15 * 1024,
	'images/maps/100/pallet.png': 23.8 * 1024,
	'images/maps/100/room1.png': 7.36 * 1024,
	'images/maps/100/room2.png': 8.42 * 1024,
	'images/maps/100/overlays/oaks.png': 905,
	'images/maps/100/overlays/pallet.png': 3.95 * 1024,
	'images/maps/100/overlays/room1.png': 614,
	'images/maps/100/overlays/room2-1.png': 432,
	'images/maps/100/overlays/room2-2.png': 433,
	'images/message/Grandma/c0c0c0-45.jpg': 1.38 * 1024,
	'images/message/Grandma/c0c0c0-65.jpg': 2.06 * 1024,
	'images/message/Grandma/c0c0c0-66.jpg': 2.08 * 1024,
	'images/message/Grandma/ffffff-45.jpg': 1.39 * 1024,
	'images/message/Grandma/ffffff-66.jpg': 2.07 * 1024,
	'images/message/Leaf/d8ffd8-19.jpg': 921,
	'images/message/Leaf/d8ffd8-45.jpg': 1.39 * 1024,
	'images/message/Leaf/ffffff-45.jpg': 1.39 * 1024,
	'images/notice/music/000000.gif': 303,
	'images/preloader/bar.gif': 151,
	'images/preloader/item.gif': 211,
	'images/preloader/quick7.gif': 2.87 * 1024,
	'images/preloader/round.gif': 208,
	'images/say/corner/000000-ffffff.gif': 75,
	'images/say/corner/808080-000000.gif': 75,
	'images/say/corner/909090-000000.gif': 75,
	'images/say/corner/a0a0a0-000000.gif': 75,
	'images/say/corner/a0a0a0-ff0000.gif': 75,
	'images/say/corner/c0c0c0-000000.gif': 75,
	'images/say/corner/d0d0d0-000000.gif': 75,
	'images/say/corner/d8ffd8-000000.gif': 75,
	'images/say/corner/e0e0e0-000000.gif': 75,
	'images/say/corner/f0f0f0-000000.gif': 75,
	'images/say/corner/ff0000-0000ff.gif': 75,
	'images/say/corner/ffffff-000000.gif': 75,
	'images/say/horizontal/000000-ffffff.gif': 36,
	'images/say/horizontal/808080-000000.gif': 36,
	'images/say/horizontal/909090-000000.gif': 36,
	'images/say/horizontal/a0a0a0-000000.gif': 36,
	'images/say/horizontal/a0a0a0-ff0000.gif': 36,
	'images/say/horizontal/c0c0c0-000000.gif': 36,
	'images/say/horizontal/d0d0d0-000000.gif': 36,
	'images/say/horizontal/d8ffd8-000000.gif': 36,
	'images/say/horizontal/f0f0f0-000000.gif': 36,
	'images/say/horizontal/ff0000-0000ff.gif': 36,
	'images/say/horizontal/ffffff-000000.gif': 36,
	'images/say/stem/808080-000000.gif': 161,
	'images/say/stem/909090-000000.gif': 161,
	'images/say/stem/c0c0c0-000000.gif': 161,
	'images/say/stem/d8ffd8-000000.gif': 161,
	'images/say/stem/f0f0f0-000000.gif': 161,
	'images/say/stem/ffffff-000000.gif': 161,
	'images/say/vertical/000000-ffffff.gif': 36,
	'images/say/vertical/808080-000000.gif': 36,
	'images/say/vertical/909090-000000.gif': 36,
	'images/say/vertical/a0a0a0-000000.gif': 36,
	'images/say/vertical/a0a0a0-ff0000.gif': 36,
	'images/say/vertical/c0c0c0-000000.gif': 36,
	'images/say/vertical/d0d0d0-000000.gif': 36,
	'images/say/vertical/d8ffd8-000000.gif': 36,
	'images/say/vertical/f0f0f0-000000.gif': 36,
	'images/say/vertical/ff0000-0000ff.gif': 36,
	'images/say/vertical/ffffff-000000.gif': 36,
	'sound/music/by/_Jensan/Retro.mp3': 941 * 1024,
	'sound/music/by/_Paulius_Jurgelevicius/Fast.mp3': 185 * 1024,
	'sound/music/by/_YD/Remember_Winter.mp3': 1127 * 1024,
	'sound/music/by/Raivu/Macrocosmos.mp3': 1.83 * 1024 * 1024
};

var fileSizeDotPhp = function(filename) {
	return [
		filename,
		Object.prototype.hasOwnProperty.call(fileSizeDotPhpSizes, filename) ?
			fileSizeDotPhpSizes[filename] :
			0
	];
};

Array.prototype.contains = function(needle) {
  if (typeof(needle) == "object") {
    for (var x = 0; x < needle.length; x++) {
      if (this.contains(needle[x]))
        return true;
    }
    return false;
  }
  for (var x = 0; x < this.length; x++) {
    if (this[x] === needle)
      return true;
  }
  return false;
};

Array.prototype.pushUnique = function(needle) {
  if (!this.contains(needle))
    this.push(needle);
  return this;
};

Array.prototype.remove = function(needle) {
  for (var x = 0; x < this.length; x++) {
    if (this[x] === needle) {
      this.splice(x, 1);
      x--;
    }
  }
  return this;
};

$["fn"].boxShadow = function(xOffset, yOffset, blurRadius, shadowColor) {
  // Created by Martin Hintzmann 2008 martin [a] hintzmann.dk
  // MIT (http://www.opensource.org/licenses/mit-license.php) licensed.
  if (!$.browser.msie)
    return this;
  return this.each(
    function() {
      $(this).css({
        position: "relative",
        zoom: 1,
        zIndex: "2"
      });
      $(this).parent().css("position", "relative");
      var temp = document.createElement("div");
      $(this).parent().append(temp);
      var _height = $(this).outerHeight(),
        _left = xOffset,
        _top = yOffset,
        _width = $(this).outerWidth();
      if (blurRadius != 0) {
        $(temp).css("filter", "progid:DXImageTransform.Microsoft.Blur(pixelRadius=" + blurRadius + ", enabled='true')");
        _height += 1;
        _left -= blurRadius + 1;
        _top -= blurRadius + 1;
        _width += 1;
      }
      $(temp).css({
        backgroundColor: shadowColor,
        height: _height + "px",
        left: _left + "px",
        position: "absolute",
        top: _top + "px",
        width: _width + "px",
        zIndex: 1
      });
    }
  );
};

$["fn"].scroll = function(x, y, w, h) {
  var bp = this.css("background-position") || "0 0";
  var bp = bp.match(/^(\-?[\d\.]+)(?:px)?\s+(\-?[\d\.]+)(?:px)?$/);
  bp[1] = parseFloat(bp[1]);
  bp[2] = parseFloat(bp[2]);
  if (typeof(w) == "number") {
    if (bp[1] > w)
      bp[1] -= w;
    else if (bp[1] < -1 * w)
      bp[1] += w;
  }
  if (typeof(h) == "number") {
    if (bp[2] > h)
      bp[2] -= h;
    else if (bp[2] < -1 * h)
      bp[2] += h;
  }
  return this.scrollTo(bp[1] + x, bp[2] + y);
};

$["fn"].scrollTo = function(x, y) {
  return this.css("background-position", x + "px " + y + "px");
};

$["fn"].slide = function(x, y) {
  if (this.length) {
    var left = this.css("left"),
      top = this.css("top");
    left = parseFloat((left == "auto" ? "0" : left).match(/^(\-?[\d\.]+)(?:px)?/)[1]);
    top = parseFloat((top == "auto" ? "0" : top).match(/^(\-?[\d\.]+)(?:px)?/)[1]);
    return this.slideTo(left + x, top + y);
  }
};

$["fn"].slideTo = function(x, y) {
  return this.css({
    left: x + "px",
    top: y + "px"
  });
};

var GAME = {
  $debug: $("#debug > div"),
  $debugWrapper: $("#debug"),
  $document: $(document),
  $gamengine: $("#gamengine"),
  $head: $("head"),
  $notice: null,
  $preloader: null,
  $window: $(window),
  callbacks: {},

  // create a character
  character: function(o, p) {

    // Is the character the player?
    p = typeof(p) != "undefined" ? p : false;

    GAME.debug("Creating " + (p ? "player" : "character #" + GAME.characters.length) + (typeof(o.character) != "undefined" ? ": " + o.character : "."));

    // Create the character's object.
    // Unless that character is the player and the player has already been created (no need to recreate, and may cause error if character object changes during this function's execution).
    if (
      typeof(p) != "number" ||
      !(0 in GAME.characters) ||
      !("direction" in GAME.characters[0])
    )
      o = $.extend(
        true,
        {
          background: "ffffff",
          callbacks: {},
          canBeInvisible: false,
          character: "NPC",
          cooldowns: {},
          direction: [],
          directionForce: [],

          // Update step sprite.
          displayStep: function() {
            GAME.functions.displayStep(this.id);
          },
          facePlayer: function() {
            GAME.functions.facePlayer(this.id);
          },
          facing: 4,
          foot: 0,
          foreground: "000000",
          height: 16,
          image: "none",
          invisible: false,
          loaded: null,
          message: function() {
            var temp = [this.id];
            for (var x = 0; x < arguments.length; x++)
              temp.push(arguments[x]);
            GAME.message(temp);
          },
          name: "Anonymous",
          offset: [0, 0],
          position: [0, 0],
          running: false,
          say: function() {
            GAME.say(this.id, arguments, 0);
          },
          speed: {
            run: 500,
            walk: 1000
          },
          step: function() {
            for (var x = 0; x < arguments.length; x++) {
              if (typeof(arguments[x]) == "function")
                this.callbacks.step = arguments[x];
              else
                this.directionForce.unshift(arguments[x]);
            }
            GAME.functions.step(this.id);
          },

          // force stop walking
          stop: function() {
            this.direction = [];

            // Disabling running here will disable running when no arrow keys are pressed, even if run key is still held, which will disable running whenever arrow keys are pressed again.
            // this.running = false;

            // If they're on an odd step, go to the next feet-together pose.
            if (this.foot % 2)
              this.foot = (this.foot + 1) % 4;

            // Display feet together.
            this.$.scrollTo(0, (4 - this.facing) * -1 * this.height);
          },
          timeouts: {},
          width: 16
        },

        // Default character settings.
        typeof(o.character) != "undefined" &&
        typeof(GAME.characterSettings[o.character]) != "undefined" ?
        GAME.characterSettings[o.character] :
        {},

        // Custom character settings.
        o
      );
    o.id = typeof(p) == "number" ? 0 : GAME.characters.length;

    // create the character's element
    var append = '<div class="character" id="character-' + o.id + '"><\/div>';
    if (typeof(p) == "number")
      GAME.$gamengine.append(append);
    else
      GAME.characters[0].$.after(append);
    o.$ = $("#character-" + o.id);

    // position the character
    GAME.preloader.quick(
      GAME.url + "images/characters/" + GAME.timeOfDay(true) + "/" + o.image,
      function() {
        o.$.css({
          backgroundImage: o.image == "none" ? "none" : 'url("' + GAME.url + 'images/characters/' + GAME.timeOfDay(true) + '/' + o.image + '")',
          backgroundPosition: "0 " + (4 - o.facing) * -1 * o.height + "px",
          height: o.height.toString() + "px",
          left: (

            // center of the screen
            (320 - Math.round(o.width / 2) + o.offset[0]) +

            // offset for non-players by the number of blocks away from the player
            (typeof(p) == "number" ? 0 : (o.position[0] - GAME.characters[0].position[0]) * GAME.map.maps[GAME.map.current].block)
          ).toString() + "px",
          marginBottom: "-" + o.height.toString() + "px",
          top: (

            // center of the screen
            (240 - Math.round(o.height / 2) + o.offset[1]) +

            // offset for non-players by the number of blocks away from the player
            (typeof(p) == "number" ? 0 : (o.position[1] - GAME.characters[0].position[1]) * GAME.map.maps[GAME.map.current].block)
          ).toString() + "px",
          width: o.width.toString() + "px",
          zIndex: (

            // Place the player at 1000 per overlay.
            typeof(p) == "number" ?
            p :

            // Main character's overlay
            Math.floor(parseFloat(GAME.characters[0].$.css("z-index").toString().match(/[\-\d]+/)[0]) / 1000)
          ) * 1000 + o.position[1]
        });

        // Store the character.
        GAME.characters[o.id] = o;

        // Function to run on load.
        if (typeof(GAME.characters[o.id].loaded) == "function") {
          GAME.debug("Executing character callback.");
          GAME.characters[o.id].loaded(o.id);
        }
      }
    );
    return o.id;
  },
  characters: [{}],
  characterSettings: {
    Grandma: {
      background: "c0c0c0",
      foreground: "000000",
      height: 21,
      image: "pokemon/grandma.gif",
      offset: [0, -2],
      speed: {
        run: null,
        walk: 750
      },
      width: 16
    },
    Janus: {
      height: 24,
      image: "chrono-trigger/janus.gif",
      offset: [0, -2],
      speed: {
        run: null,
        walk: 250
      },
      width: 14
    },
    Leaf: {
      background: "d8ffd8",
      foreground: "000000",
      height: 21,
      image: "pokemon/leaf.gif",
      offset: [0, -2],
      speed: {
        run: 150,
        walk: 250
      },
      width: 16
    },
    Red: {
      height: 21,
      image: "pokemon/red.gif",
      offset: [0, -2],
      speed: {
        run: 150,
        walk: 250
      },
      width: 16
    },
    Schala: {
      height: 31,
      image: "chrono-trigger/schala.gif",
      offset: [0, -2],
      speed: {
        run: null,
        walk: 250
      },
      width: 16
    },
    Tata: {
      height: 24,
      image: "chrono-trigger/tata.gif",
      offset: [-1, -2],
      speed: {
        run: null,
        walk: 250
      },
      width: 18
    },
    Toma: {
      height: 32,
      image: "chrono-trigger/toma.gif",
      offset: [-1, -2],
      speed: {
        run: null,
        walk: 250
      },
      width: 18
    }
  },
  choice: function() {
    if (!GAME.is("message", "preload")) {
      GAME.doing.choice = true;
      GAME.callbacks.choice = arguments[arguments.length - 1];

      // store all messages
      GAME.data.choices = [];
      for (var x = 0; x < arguments.length - 1; x++)
        GAME.data.choices.push(arguments[x]);

      GAME.debug("Creating choice menu: " + GAME.data.choices.join(", "));

      // the choice element
      var $message = $(document.createElement("ul"))
        .addClass("choice")
        .css({
          zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
        })
        .html(
          '<li class="selected">' + GAME.data.choices.join('</li><li>') + '</li>'
        );
      GAME.$gamengine.append($message);
      return true;
    }
    return false;
  },
  credits: function(music) {
    GAME.doing.preload = true;
    GAME.$gamengine.empty();
    GAME.$gamengine.append('<div id="credits"><\/div>');
    GAME.credit = 0;
    GAME.$credits = $("#credits");
    GAME.$$credits = [];
    GAME.map.clearTimeouts();
    GAME.sound.stop();
    GAME.sound.play(music);
    for (var x = 1; x < arguments.length; x++) {
      GAME.$credits.append('<div id="credits-' + x + '">' + arguments[x] + '<\/div>');
      GAME.$$credits[x - 1] = $("#credits-" + x);
      GAME.$$credits[x - 1].fadeTo(0, 0);
      setTimeout(
        function() {
          GAME.$$credits[GAME.credit].css("top", (480 - GAME.$$credits[GAME.credit].height()) / 2 + "px");
          GAME.$$credits[GAME.credit].fadeTo(1000, 1,
            function() {
              setTimeout(
                function() {
                  if (GAME.credit != GAME.$$credits.length - 1)
                    GAME.$$credits[GAME.credit].fadeTo(1000, 0,
                      function() {
                        GAME.$$credits[GAME.credit - 1].remove();
                      }
                    );
                  GAME.credit++;
                },
                3000
              );
            }
          );
        },
        5000 * (x - 1)
      );
    }
  },
  data: {},
  debug: function(x) {
    if (GAME.doing.debug) {
      if (typeof(x) == "object") {
        var numeric = 0,
          temp = x,
          total = 0,
          y = [],
          y2 = [];
        for (var z in temp) {
          if (typeof(temp[z]) != "function") {
            total++;
            if (z.match(/^\d+$/)) {
              numeric++;
              y2.push(temp[z]);
            }
            y.push(z + ": " + temp[z]);
          }
        }
        if (numeric == total)
          y = y2.join(", ");
        else
          y = y.join(",<br />");
      }
      else if (typeof(x) == "boolean")
        var y = x ? "true" : "false";
      else
        var y = x;
      GAME.$debug.append(y + "<br />");
      GAME.$debug.parent().scrollTop(GAME.$debug.height());
    }
  },
  doing: {
    debug: true,
    interact: false,
    map: false,
    message: false,
    preload: false,
    step: false
  },
  format: function(n) {
    n = n.toString();
    var n2 = "";
    for (var x = 0; x < n.length; x++)
      n2 = n.charAt(n.length - 1 - x) + (x > 0 && !(x % 3) ? "," : "") + n2;
    return n2;
  },
  functions: {
    choice: function(direction) {

      // selection made
      if (typeof(direction) == "undefined") {
        var selection = $(".choice li.selected").html();
        $(".choice").remove();
        GAME.debug("Choice selected: " + selection);
        GAME.callbacks.choice(selection);
        GAME.doing.choice = false;
        return selection;
      }

      if (direction == null) {
        $(".choice li.selected").removeClass("selected").siblings().last().addClass("selected");
        return GAME.functions.choice();
      }

      if (typeof(GAME.data.lastChoiceDirection) == "undefined")
        GAME.data.lastChoiceDirection = direction;

      // changed direction without letting up on other key, ignore other key
      else if (GAME.data.lastChoiceDirection != direction) {
        GAME.data.lastChoiceDirection = direction;
        clearTimeout(GAME.timeouts.choice);
      }

      var $selected = $(".choice .selected");
      if (direction == 38) {
        var $new = $selected.prev();
        if (!$new.length)
          $new = $selected.siblings().last();
      }
      else {
        var $new = $selected.next();
        if (!$new.length)
          $new = $selected.siblings().first();
      }
      $selected.removeClass("selected");
      $new.addClass("selected");
      GAME.timeouts.choice = setTimeout(
        function() {
          // if last direction key pressed is still active,
          if (GAME.keys.active[GAME.data.lastChoiceDirection])
            GAME.functions.choice(GAME.data.lastChoiceDirection);

          // if they released the last key pressed but are still holding down the other direction,
          else if (GAME.keys.active[GAME.data.lastChoiceDirection == 38 ? 40 : 38])
            GAME.functions.choice(GAME.data.lastChoiceDirection == 38 ? 40 : 38);
        },
        200
      );
      return $new.html();
    },
    direction: {
      down: function(keyCode) {
        if (
          typeof(GAME.characters[0]) == "object" &&
          "direction" in GAME.characters[0]
        ) {
          GAME.characters[0].direction.pushUnique(keyCode);
          if (!GAME.is("preload", "step"))
            GAME.characters[0].step();
        }
      },
      up: function(keyCode) {
        if (
          typeof(GAME.characters[0]) == "object" &&
          "direction" in GAME.characters[0]
        )
          GAME.characters[0].direction.remove(keyCode);
      }
    },
    displayStep: function(id) {
      GAME.characters[id].$.scrollTo(
        (
          (GAME.characters[id].running ? 3 : 0) + // running sprites are 3 spots over on the sprite sheet
          GAME.characters[id].foot % 2 + // step 0 and 2 at position 0
          (GAME.characters[id].foot == 3 ? 1 : 0) // step 3 at position 2 (step % 2 + 1)
        ) * -1 * GAME.characters[id].width,
        (
          4 - GAME.characters[id].facing // starting at 4 (below sprite sheet), move up 1 for each direction
        ) * -1 * GAME.characters[id].height
      );
    },
    enter: function(x, y) {

      // Get the function.
      var enter = GAME.map.maps[GAME.map.current].enter[y + 1][x + 1];
      if (typeof(enter) == "object")
        enter = enter[GAME.characters[0].facing - 1];

      // If the entrance is a string, make it a function.
      if (typeof(enter) == "string")
        enter = GAME.map.maps[GAME.map.current].functions[enter];

      // If an entrance exists,
      if (typeof(enter) == "function") {

        // Force stop running.
        //GAME.characters[0].running = false;

        // Force stop walking.
        //GAME.characters[0].stop();

        // Execute the function.
        enter();
        return true;
      }
      return false;
    },
    facePlayer: function(id) {
      // 1>3, 2>4, 3>1, 4>2
      GAME.characters[id].facing = GAME.characters[0].facing + (GAME.characters[0].facing < 3 ? 2 : -2);
      GAME.characters[id].displayStep();
    },
    interact: function() {
      if (!GAME.is("interact", "preload")) {

        // Check character interactions.
        for (var x = 1; x < GAME.characters.length; x++) {
          if (
            // 1>-1, 2>0, 3>1, 4>0
            GAME.characters[x].position[0] == Math.round(GAME.characters[0].position[0] - Math.sin(GAME.characters[0].facing * Math.PI / 2)) &&
            // 1>0, 2>-1, 3>0, 4>1
            GAME.characters[x].position[1] == Math.round(GAME.characters[0].position[1] + Math.cos(GAME.characters[0].facing * Math.PI / 2)) &&
            typeof(GAME.characters[x].interaction) == "function"
          ) {

            // Force stop running.
            // GAME.characters[0].running = false;

            // Force stop walking.
            GAME.characters[0].stop();

            // Execute the interaction.
            GAME.doing.interact = GAME.characters[x].interaction();
            if (typeof(GAME.doing.interact) == "undefined")
              GAME.doing.interact = false;
            return true;
          }
        }

        // Get the interaction.
        var interaction = GAME.map.maps[GAME.map.current].interaction,
          y = Math.round(GAME.characters[0].position[1] + 1 + Math.cos(GAME.characters[0].facing * Math.PI / 2)); // 0.999... fffffffuuuuuuuuuuuu

        // If we're in a defined vertical area of the map,
        if (y in interaction) {
          interaction = interaction[y];

          // If we're in a defined horizontal area of the map,
          var x = Math.round(GAME.characters[0].position[0] + 1 + Math.sin(GAME.characters[0].facing * Math.PI / 2) * -1); // 0.999... fffffffuuuuuuuuuuuu
          if (x in interaction) {
            interaction = interaction[x];

            // If the interaction is directional,
            if (typeof(interaction) == "object")

              // 1>2, 2>3, 3>0, 4>1
              interaction = interaction[GAME.characters[0].facing + (GAME.characters[0].facing > 2 ? -3 : 1)];

            // If an interaction exists,
            if (typeof(interaction) == "function") {

              // Force stop running.
              // GAME.characters[0].running = false;

              // Force stop walking.
              GAME.characters[0].stop();

              // Execute the interaction.
              GAME.doing.interact = interaction();
              if (typeof(GAME.doing.interact) == "undefined")
                GAME.doing.interact = false;
              return true;
            }
          }
        }
      }
      return false;
    },
    step: function(id) {
      var direction = null;

      // If a direction is being forced,
      if (typeof(GAME.characters[id].directionForce[0]) != "undefined") {
        if (!GAME.is("choice", "message", "preload"))
          direction = GAME.characters[id].directionForce.pop();
      }

      // Main character's manual steps.
      else {

        // Don't step if...
        if (!GAME.is("choice", "message", "preload", "step")) {
          GAME.doing.step = true;

          // Calculate direction of travel.
          direction = GAME.characters[0].direction[GAME.characters[0].direction.length - 1];
          direction = [37, 65].contains(direction) ? 1 :
            [38, 87].contains(direction) ? 2 :
            [39, 68].contains(direction) ? 3 :
            4;
        }
      }

      if (direction != null) {

        // Calculate direction.
        GAME.characters[id].facing = direction;

        // Step
        GAME.characters[id].foot = (GAME.characters[id].foot + 1) % 4;

        /*
        // Only footsteps when running.
        if (
          GAME.characters[0].running &&
          GAME.characters[0].foot % 2 == 0
        )
          GAME.characters[0].foot++;
        /**/

        // Display step.
        GAME.characters[id].displayStep();

        // Calculate new position.
        var position = [
          GAME.characters[id].position[0] + (direction == 1 ? -1 : (direction == 3 ? 1 : 0)),
          GAME.characters[id].position[1] + (direction == 2 ? -1 : (direction == 4 ? 1 : 0))
        ];

        // Is the position blocked?
        var blocked = GAME.map.maps[GAME.map.current].blocked;
        if (typeof(blocked[position[1] + 1]) == "object") {
          blocked = blocked[position[1] + 1][position[0] + 1];
          if (typeof(blocked) == "object")
            blocked = blocked[(direction + 1) % 4];
        }
        else
          blocked = 1;
        for (var x = 0; x < GAME.characters.length; x++) {
          if (
            GAME.characters[x].position[0] == position[0] &&
            GAME.characters[x].position[1] == position[1]
          ) {
            blocked = 1;
            break;
          }
        }

        // If the position isn't blocked,
        if (!blocked) {

          // Update z-index
          GAME.characters[id].$.css("z-index", Math.floor(parseFloat(GAME.characters[id].$.css("z-index").toString().match(/[\-\d]+/)[0]) / 1000) * 1000 + position[1]);

          // Direction of scroll.
          // COS: 0=> 1, 1=> 0, 2=>-1, 3=> 0, 4=> 1
          // SIN: 0=> 0, 1=> 1, 2=> 0, 3=>-1, 4=> 0
          var u = direction * Math.PI / 2,
            x = 0, y = 0;

          // Player X:   1=> 1, 2=> 0, 3=>-1, 4=> 0
          // Player Y:   1=> 0, 2=> 1, 3=> 0, 4=>-1
          if (id == 0) {
            x = Math.sin(u);
            y = -1 * Math.cos(u);
          }

          // NPC X:      1=>-1, 2=> 0, 3=> 1, 4=> 0
          // NPC Y:      1=> 0, 2=>-1, 3=> 0, 4=> 1
          else {
            x = -1 * Math.sin(u);
            y = Math.cos(u);
          }
          x = Math.round(x);
          y = Math.round(y);

          // Update position.
          GAME.characters[id].position = [position[0], position[1]];

          // Characters are now [block] pixels away from their position.
          GAME.characters[id].offset[0] += GAME.map.maps[GAME.map.current].block * x * -1;
          GAME.characters[id].offset[1] += GAME.map.maps[GAME.map.current].block * y * -1;

          // Animate
          for (var z = 0; z < GAME.map.maps[GAME.map.current].block; z++) {

            // For the main character, scroll everything except the main character.
            if (id == 0) {
              setTimeout(
                function() {

                  // Set the pixel offset of the main character (and thus the screen)
                  GAME.characters[0].offset[0] += x;
                  GAME.characters[0].offset[1] += y;

                  // For each overlay,
                  var overlays = GAME.map.maps[GAME.map.current].overlays; 
                  for (var a = 0; a < overlays.length; a++) {

                    // Excluding the character,
                    if (typeof(overlays[a]) == 'object')

                      // Scroll the overlay.
                      // Shift by the new direction times parallax
                      overlays[a].$.scroll(

                        // 1->1, 2->0, 3->-1, 4->0
                        overlays[a].parallax[0] * x,

                        // 1->0, 2->1, 3->0, 4->-1
                        overlays[a].parallax[1] * y
                      );
                  }

                  // For each say box,
                  $(".say:not(.say-0)").slide(x, y);

                  // Scroll each NPC,
                  for (var a = 1; a < GAME.characters.length; a++)
                    GAME.characters[a].$.slide(x, y);
                },
                z * GAME.characters[0].speed[GAME.characters[0].running ? "run" : "walk"] / GAME.map.maps[GAME.map.current].block
              );
            }

            // For NPCs, scroll just the NPC.
            else {
              var temp = "step" + z;
              GAME.characters[id].timeouts[temp] = setTimeout(
                function() {

                  // Set the offset so that the say box can follow them.
                  GAME.characters[id].offset[0] += x;
                  GAME.characters[id].offset[1] += y;

                  // Slide the character.
                  GAME.characters[id].$.slide(x, y);

                  // Slide the say box.
                  $(".say-" + id).slide(x, y);
                },
                z * GAME.characters[id].speed[GAME.characters[id].running ? "run" : "walk"] / GAME.map.maps[GAME.map.current].block
              );
            }
          }

          // Finish movement and move the character's position.
          // GAME.doing.step = false; is both here and in the else statement to ensure that it runs prior to enter(), so that enter functions that measure step know that the step has completed.
          // While step will always be false for an enter function, an enter function may still measure step because the function may also be used outside of enter(), such as a map function.
          if (id == 0)
            setTimeout(
              "GAME.doing.step = false; GAME.functions.enter(" + position[0] + ", " + position[1] + ");",
              GAME.characters[0].speed[GAME.characters[0].running ? "run" : "walk"]
            );
        }

        // Main character is blocked.
        else if (id == 0)
          setTimeout(
            "GAME.doing.step = false;",
            GAME.characters[0].speed[GAME.characters[0].running ? "run" : "walk"]
          );

        // NPC is blocked
        else
          GAME.characters[id].directionForce.push(direction);
      }
      GAME.characters[id].timeouts.step = setTimeout(
        function() {

          // Definitely display movement sprites when waiting!
          // This also erroneously removes characters[0].direction when preloading.
          // Waiting on something, don't display movement sprites.
          //if (direction == null)
          //  GAME.characters[id].stop();

          // If the character is still walking, step again.
          if (
            GAME.characters[id].direction.length ||
            GAME.characters[id].directionForce.length
          )
            GAME.characters[id].step();

          // Otherwise, stop the animation.
          else {
            GAME.characters[id].stop();
            if (typeof(GAME.characters[id].callbacks.step) == "function") {
              // GAME.debug("Executing step callback for character #" + id + ".");
              GAME.characters[id].callbacks.step();
            }
          }
        },
        (direction == null ? 50 : GAME.characters[id].speed[GAME.characters[id].running ? "run" : "walk"])
      );
    }
  },
  is: function() {
    for (var x = 0; x < arguments.length; x++) {
      if (
        typeof(GAME.doing[arguments[x]]) == "boolean" &&
        GAME.doing[arguments[x]]
      )
        return true;
    }
    return false;
  },
  keys: {
    active: [],
    binds: {
      down: {
        // enter
        13: function() {
          if (GAME.is("choice"))
            return GAME.functions.choice();
          else if (GAME.is("message"))
            return GAME.message();
          else {
            GAME.choice(
              "Controls",
              "Save",
              "Options",
              "Reset",
              "Close",
              function(a) {
                if (a == "Controls")
                  GAME.message(
                    "Arrow keys allow you to move.",
                    "Hold S to run.",
                    "Press D to interact with people, your environment, and messages.",
                    "Press 0 to mute or unmute the game.",
                    "Press - to decrease and = to increase the volume.",
                    "Press R to reload the game.",
                    "Press Enter to open the menu."
                  );
                else if (a == "Save")
                  GAME.message("Saving has not been programmed yet.");
                else if (a == "Options")
                  GAME.message("Options have not been programmed yet.");
                else if (a == "Reset")
                  location.reload();
              }
            );
          }
        },
        // space
        32: function() {
          if (GAME.is("choice"))
            return GAME.functions.choice();
        },
        // left
        37: function(e) {
          return GAME.functions.direction.down(e);
        },
        // up
        38: function(e) {
          if (GAME.is("choice"))
            return GAME.functions.choice(38);
          return GAME.functions.direction.down(e);
        },
        // right
        39: function(e) {
          return GAME.functions.direction.down(e);
        },
        // down
        40: function(e) {
          if (GAME.is("choice"))
            return GAME.functions.choice(40);
          return GAME.functions.direction.down(e);
        },
        // 0
        48: function(e) {
          if (GAME.sound.enabled)
            GAME.sound.mute();
          else
            GAME.sound.unmute();
        },
        /* a
        65: function(e) {
          return GAME.functions.direction.down(e);
        }, */
        // d
        68: function(e) {

          // Respond to an message window.
          if (GAME.is("message"))
            GAME.message();

          else if (GAME.is("choice"))
            GAME.functions.choice();

          // No message window.
          else {
            GAME.functions.interact();

            // Force unpress, since browser won't signal unpress during certain interactions, such as message().
            GAME.keys.up({keyCode: 68});
          }
        },
        // r
        82: function(e) {
          window.location.reload();
        },
        // s
        83: function(e) {
          if (typeof(GAME.characters[0].speed.run) == "number")
            GAME.characters[0].running = true;

          // Cancel choice selection.
          if (GAME.is("choice"))
            GAME.functions.choice(null);
          else if (GAME.is("message"))
            GAME.message();
          else {

            // Phantom
            if (GAME.characters[0].character == "Phantom") {

              // Not on cooldown.
              if (GAME.characters[0].canBeInvisible) {
                GAME.characters[0].invisible = true;
                GAME.characters[0].displayStep();

                // Force release of run key.
                GAME.timeouts.phantomInvisible = setTimeout("GAME.keys.up({keyCode: 83});", GAME.characters[0].speed.invisibility);
              }
            }
          }
        },
        /* s
        83: function(e) {
          return GAME.functions.direction.down(e);
        }, */
        /* w
        87: function(e) {
          return GAME.functions.direction.down(e);
        },*/
        // numpad 0
        96: function() {
          if (GAME.sound.enabled)
            GAME.sound.mute();
          else
            GAME.sound.unmute();
        },
        // =
        187: function(e) {
          GAME.sound.volume(25);
        },
        // -
        189: function(e) {
          GAME.sound.volume(-25);
        }
      },
      up: {
        /* space
        32: function() {
          GAME.characters[0].running = false;
        }, */
        // left
        37: function(e) {
          return GAME.functions.direction.up(e);
        },
        // up
        38: function(e) {
          if (GAME.is("choice"))
            return clearTimeout(GAME.timeouts.choice);
          return GAME.functions.direction.up(e);
        },
        // right
        39: function(e) {
          return GAME.functions.direction.up(e);
        },
        // down
        40: function(e) {
          if (GAME.is("choice"))
            return clearTimeout(GAME.timeouts.choice);
          return GAME.functions.direction.up(e);
        },
        /* a
        65: function(e) {
          return GAME.functions.direction.up(e);
        }, */
        /* d
        68: function(e) {
          return GAME.functions.direction.up(e);
        }, */
        // s
        83: function(e) {
          GAME.characters[0].running = false;

          // Phantom
          if (GAME.characters[0].character == "Phantom") {
            GAME.characters[0].canBeInvisible = false;
            GAME.characters[0].invisible = false;
            GAME.characters[0].displayStep();
            clearTimeout(GAME.timeouts.phantomInvisible);

            // Set cooldown.
            GAME.map.timeouts.phantomCanBeInvisible = setTimeout("GAME.characters[0].canBeInvisible = true;", GAME.characters[0].cooldowns.invisibility);
          }
        }
        /* s
        83: function(e) {
          return GAME.functions.direction.up(e);
        }, */
        /* w
        87: function(e) {
          return GAME.functions.direction.up(e);
        } */
      }
    },
    codes: {
      8: "backspace", 9: "tab", 13: "enter", 16: "shift", 17: "ctrl", 20: "capsLock",
      27: "esc", 32: " ", 33: "pageUp", 34: "pageDown", 35: "end", 36: "home",
      37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del",
      48: 0, 49: 1, 50: 2, 51: 3, 52: 4, 53: 5, 54: 6, 55: 7, 56: 8, 57: 9,
      65: "a", 66: "b", 67: "c", 68: "d", 69: "e", 70: "f", 71: "g", 72: "h", 73: "i", 74: "j", 75: "k", 76: "l", 77: "m",
      78: "n", 79: "o", 80: "p", 81: "q", 82: "r", 83: "s", 84: "t", 85: "u", 86: "v", 87: "w", 88: "x", 89: "y", 90: "z",
      91: "windows", 93: "rightClick",
      /* numpad: */ 96: 0, 97: 1, 98: 2, 99: 3, 100: 4, 101: 5, 102: 6, 103: 7, 104: 8, 105: 9,
      107: "=", 109: "-", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6",
      118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "numLk",
      186: ";", 188: ",", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'"
    },
    down: function(e) {
      if (!GAME.keys.active[e.keyCode]) {
        GAME.keys.active[e.keyCode] = true;
        if (typeof(GAME.keys.binds.down[e.keyCode]) == "function")
          GAME.keys.binds.down[e.keyCode](e.keyCode);
      }
    },
    up: function(e) {
      GAME.keys.active[e.keyCode] = false;
      if (typeof(GAME.keys.binds.up[e.keyCode]) == "function")
        GAME.keys.binds.up[e.keyCode](e.keyCode);
    }
  },
  onresize: function() {
    GAME.$debugWrapper.height(GAME.$window.height() + "px").width((GAME.$window.width() - GAME.$gamengine.width() - 1) / 2 + "px");
    GAME.$gamengine.css("margin-top", ((GAME.$window.height() - GAME.$gamengine.height()) / 2) + "px");
  },
  load: function(settings) {

    // callback
    if (typeof(settings.callback) == "function")
      GAME.map.callback = settings.callback;

    // window position
    GAME.onresize();
    GAME.$window.resize(GAME.onresize);

    // load the engine
    /*
    window.SM2_DEFER = true;
    //GAME.preloader.load([
    //  "../scripts/soundmanager2-nodebug-jsmin.js"
    //]);
    var temp = document.createElement("script");
    temp.setAttribute("src", "scripts/soundmanager2-nodebug-jsmin.js");
    temp.setAttribute("type", "text/javascript");
    temp.onload = function() {
      window.soundManager = new SoundManager(); // Flash expects window.soundManager.
      window.soundManager.flashVersion = 8;
      window.soundManager.onready(GAME.sound.ready);
      window.soundManager.ontimeout(GAME.sound.timeout);
      window.soundManager.url = "scripts/";
      window.soundManager.useFlashBlock = false;
      window.soundManager.beginDelayedInit();
    };
    document.getElementsByTagName("head").item(0).appendChild(temp);
    */

    // multiplayer
    if (typeof(settings.multiplayer) != "undefined")
      GAME.multiplayer = settings.multiplayer;

    // main character
    GAME.characters[0] = settings.character;

    // load the map
    GAME.map.load(settings.map, settings.character.position[0], settings.character.position[1]);

    // key down/up
    GAME.$document.keydown(GAME.keys.down);
    GAME.$document.keyup(GAME.keys.up);
  },
  map: {
    callback: null,
    clearTimeouts: function() {
      var z = 0;
      for (var x in GAME.map.timeouts) {
        z++;
        clearTimeout(GAME.map.timeouts[x]);
        delete GAME.map.timeouts[x];
      }
      GAME.debug("Cleared " + z + " map timeouts.");
      /*if (
        GAME.map.current &&
        typeof(GAME.map.maps[GAME.map.current].timeouts) == "object"
      ) {
        var t = GAME.map.maps[GAME.map.current].timeouts;
        GAME.debug("Clearing " + t.length + " map timeout" + (t.length != 1 ? "s" : "") + ".");
        for (var x = 0; x < t.length; x++)
          clearTimeout(t[x]);
      }*/
      for (var x = 0; x < GAME.characters.length; x++) {
        var z = 0;
        for (var y in GAME.characters[x].timeouts) {
          clearTimeout(GAME.characters[x].timeouts[y]);
          z++;
        }
        GAME.debug("Cleared " + z + " timeouts for character #" + x + ".");
      }
    },
    current: null,
    empty: function() {
      GAME.debug("Emptying map.");
      GAME.$gamengine.empty();

      // Clear timeouts.
      GAME.map.clearTimeouts();

      // Remove sounds.
      // GAME.sound.destroy();

      // Remove characters.
      for (var x = 1; x < GAME.characters.length; x++)
        GAME.characters.pop();
      // GAME.characters[0].direction = [];
    },
    load: function(name, x, y, music) {
      GAME.doing.preload = true;

      // Don't move past the map load command.
      //if ("stop" in GAME.characters[0])
      //  GAME.characters[0].stop();

      if (
        typeof(x) == "number" &&
        typeof(y) == "number"
      ) {
        GAME.characters[0].position = [x, y];

        // Carry over music to next map.
        // Can't be outside of x/y type check, because new maps downloaded from server run GAME.map.load("name") once download has completed (music parameter always undefined).
        // GAME.sound.stop();
        GAME.data.mapMusic = typeof(music) == "undefined" ? false : true;
      }

      // Only if the map exists,
      if (typeof(GAME.map.maps[name]) == "object") {
        GAME.debug("Loading map: <strong>" + name + "</strong>");

        // Remove previous map.
        GAME.map.empty();

        // Set map details.
        GAME.map.current = name;

        GAME.$gamengine.css("background-color", GAME.map.maps[name].color);

        // Preload images for the map.
        GAME.preload(
          function() {
            var map = GAME.map.maps[GAME.map.current];

            // Create the overlays.
            // GAME.debug("Creating overlays.");
            for (var i = 0; i < map.overlays.length; i++) {

              // Create main character.
              if (typeof(map.overlays[i]) == "boolean")
                GAME.character(GAME.characters[0], i);

              // Create overlay.
              else {

                // Default overlay values.
                map.overlays[i] = $.extend(
									{
                    $: {},
                    offset: [0, 0],
                    parallax: [1, 1],
                    repeat: "no-repeat"
                  },
                  map.overlays[i]
                );
                GAME.debug("Creating overlay #" + (i + 1) + ': <a href="' + GAME.url + 'images/maps/' + GAME.timeOfDay(true) + '/' + map.overlays[i].image + '">' + map.overlays[i].image + '<\/a>');
                GAME.$gamengine.append('<div class="overlay" id="overlay-' + (i + 1) + '"><\/div>');
                map.overlays[i].$ = $("#overlay-" + (i + 1));
                map.overlays[i].$.css({
                  backgroundImage: 'url("' + GAME.url + 'images/maps/' + GAME.timeOfDay(true) + '/' + map.overlays[i].image + '")',
                  backgroundPosition: (312 - GAME.characters[0].position[0] * map.overlays[i].parallax[0] * GAME.map.maps[GAME.map.current].block) + 'px ' +
                    (232 - GAME.characters[0].position[1] * map.overlays[i].parallax[1] * GAME.map.maps[GAME.map.current].block) + 'px',
                  backgroundRepeat: map.overlays[i].repeat,
                  zIndex: i * 1000
                });
              }
            }
            // GAME.debug("Overlays created.");

            // Stop previous map's music.
            if (!GAME.data.mapMusic)
              GAME.sound.stop();

            // Run finish loading function.
            if (typeof(GAME.map.maps[name].loaded) == "function")
              GAME.map.maps[name].loaded();
            GAME.debug("Map loaded.");

            // If player still walking, start walking.
            if (GAME.characters[0].direction.length)
              GAME.characters[0].step();

            // Game loaded callback.
            if (GAME.map.callback) {
              GAME.debug("Executing map callback.");
              GAME.map.callback();
              delete GAME.map.callback;
            }
          }
        );
        return true;
      }
      else {
        GAME.debug("Downloading map: <strong>" + name + "</strong>");
        GAME.script("scripts/maps/" + name + ".min.js");
      }
      return false;
    },
    maps: {},
    timeouts: {}
  },

  // message box
  message: function() {

    // If the message is loading, don't do anything.
    if (!$(".message").hasClass("hidden")) {

      $(".message").remove(); // GAME.$gamengine.remove(".message");

      // Message callback. If all messages completed, execute full callback.
      if (
        typeof(arguments[0]) == "undefined" &&
        typeof(GAME.data.messages[0]) == "undefined"
      ) {
        GAME.doing.message = false;

        // If there is a callback,
        if (typeof(GAME.callbacks.message) == "function") {
          GAME.debug("Executing message callback.");
          GAME.callbacks.message();
        }
        return true;
      }

      // Set up messages if first call.
      if (arguments.length) {
        GAME.doing.message = true;

        var messages = arguments;
        if (typeof(messages[0]) == "object")
          messages = messages[0];

        // store all messages
        GAME.data.messages = [];
        GAME.data.messageId = (typeof(messages[0]) == "number" ? messages[0] : null);
        GAME.callbacks.message = null;
        for (var x = GAME.data.messageId != null ? 1 : 0; x < messages.length; x++) {
          if (typeof(messages[x]) == "function")
            GAME.callbacks.message = messages[x];
          else
            GAME.data.messages.push(messages[x]);
        }
        GAME.debug(
          "Created " + GAME.data.messages.length + " message" + (GAME.data.messages.length != 1 ? "s" : "") +
          (GAME.data.messageId != null ? " for character #" + GAME.data.messageId : "") +
          (typeof(GAME.callbacks.message) == "function" ? " with callback" : "") + "."
        );
      }

      var message = GAME.data.messages.shift();

      // the message element
      var $message = $('<div class="message"><div>' + message + '<\/div><\/div>')
        .css({
          //fontFamily: (typeof(message.font) == "string" ? message.font : ""),
          zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
        });

      // If a portrait will be added, hide the message until it has loaded.
      if (GAME.data.messageId != null)
        $message.addClass("hidden");

      // If someone is saying the message,
      if (GAME.data.messageId != null)
        $message.addClass(GAME.characters[GAME.data.messageId].character).css({
          backgroundColor: "#" + GAME.characters[GAME.data.messageId].background,
          borderColor: "#" + GAME.characters[GAME.data.messageId].foreground,
          color: "#" + GAME.characters[GAME.data.messageId].foreground
        });
      GAME.$gamengine.append($message);

      // Add the speaker's portrait to the message.
      if (GAME.data.messageId != null) {
        var portrait = GAME.url + "images/message/" + GAME.characters[GAME.data.messageId].character + "/" + GAME.characters[GAME.data.messageId].background + "-" + $message.height() + ".jpg";
        GAME.preloader.quick(
          portrait,
          function() {
            $message.css(
              "background-image",
              'url("' + portrait + '")'
            );
            $message.removeClass("hidden");
          }
        );
      }
      return true;
    }
    return false;
  },
  multiplayer: false,
  notice: function(str) {
    $("#notice").remove();
    GAME.debug("Notice: " + str);
    GAME.$notice = $('<div id="notice">' + str + '<\/div>').fadeTo(0, 0).boxShadow(12, 12, 12, "#202020");
    GAME.$gamengine.append(GAME.$notice);
    GAME.$notice.css({
      marginRight: "-" + GAME.$notice.outerWidth() + "px",
      zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
    });
    GAME.$notice.fadeTo(
      500, 1,
      function() {
        GAME.map.timeouts.notice = setTimeout(
          function() {
            // $("#notice") keeps fading even if it gets deleted and replaced with a different one
            // i.e. if you change the map mid-fade, the new notice will be removed.
            GAME.$notice.fadeTo(
              500, 0,
              function() {
                GAME.$notice.remove();
              }
            );
          },
          2000
        );
      }
    );
  },

  // percentage rounded to two decimal places
  percent: function(a, b) {
    return Math.round(a / b * 10000) / 100 + "%"
  },
  preload: function(callback) {
    GAME.doing.preload = true;

    var i = [],
      map = GAME.map.maps[GAME.map.current];

    /*
    for (var x = 0; x < arguments.length; x++) {
      if (typeof(arguments[x]) == "object") {
        for (var y = 0; y < arguments[x].length; y++)
          i.push(arguments[x][y]);
      }
      else
        i.push(arguments[x]);
    }
    */

    i.push(GAME.url + "images/characters/" + GAME.timeOfDay(true) + "/" + GAME.characterSettings[GAME.characters[0].character].image);
    i.push("images/preloader/round.gif");
    i.push("images/preloader/bar.gif");
    i.push("images/preloader/item.gif");
    //i.push(GAME.url + "images/say/corner/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");
    //i.push(GAME.url + "images/say/horizontal/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");
    //i.push(GAME.url + "images/say/stem/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");
    //i.push(GAME.url + "images/say/vertical/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");

    // overlays
    if (typeof(map.overlays) == "object") {
      for (x = 0; x < map.overlays.length; x++) {
        if (typeof(map.overlays[x].image) == "string")
          i.push(GAME.url + "images/maps/" + GAME.timeOfDay(true) + "/" + map.overlays[x].image);
      }
    }

    // sound
    if (
      GAME.sound.supported &&
      typeof(map.sound) == "object"
    ) {
      for (x = 0; x < map.sound.length; x++) {
        var id = map.sound[x].match(/\/?([\d\-\.\w]+?)\.(?:mid|mp3|ogg|wav)$/)[1];

        // don't download sounds already loaded
        if (!soundManager.getSoundById(id))
          i.push("sound/" + map.sound[x]);
      }
    }

    // images in the map
    if (typeof(map.imgs) == "object") {
      for (x = 0; x < map.imgs.length; x++)
        i.push("images/" + map.imgs[x]);
    }
    GAME.preloader.load(i, typeof(callback) == "function" ? callback : null);
  },
  preloader: {
    callback: null,
    checkpoint: 0,
    complete: function() {
      // GAME.debug("Preloading complete.");
      GAME.doing.preload = false;
      if (typeof(GAME.preloader.callback) == "function") {
        // GAME.debug("Executing preload callback.");
        GAME.preloader.callback();
      }
    },
    delay: 0,
    done: 0,
    faux: function() {
      var thus = (GAME.preloader.totalBytes / GAME.preloader.totalTime) * // bytes per second
          (new Date().getTime() - GAME.preloader.started); // seconds
      thus = Math.min(thus, GAME.preloader.thus + GAME.preloader.todo[GAME.preloader.done][1]);
      var percent = GAME.percent(thus, GAME.preloader.total);
      GAME.preloader.$bar2.width(percent);
      GAME.preloader.$percent.html(percent);
      GAME.preloader.$thus.html(GAME.format(Math.round(thus)));
      GAME.preloader.timeouts[1] = setTimeout(GAME.preloader.faux, 20);
    },
    init: function(todo) {
      GAME.preloader.todo = todo;
      GAME.preloader.started = new Date().getTime();
      GAME.preloader.checkpoint = GAME.preloader.started;
      for (var x = 0; x < GAME.preloader.todo.length; x++)
        GAME.preloader.total += GAME.preloader.todo[x][1];
      GAME.preloader.$total.html("<span>0</span> / " + GAME.format(GAME.preloader.total));
      GAME.preloader.$thus = GAME.preloader.$total.children("span").first();
      GAME.preloader.next();
    },
    load: function(a, callback) {
      // GAME.debug("Preloading...");
      GAME.doing.preload = true;
      if (typeof(callback) == "function")
        GAME.preloader.callback = callback;
      else
        GAME.preloader.callback = null;
      var b = [];

      // Don't preload items that we've loaded this session.
      for (var x = 0; x < a.length; x++) {
        if (!GAME.preloader.past.contains(a[x]))
          b.push(a[x]);
      }
      if (b.length) {
        GAME.preloader.done = 0;
        GAME.preloader.thus = 0;
        GAME.preloader.total = 0;
        GAME.$gamengine.append(
          '<div id="preloader">' +
            '<div id="preloader-area"><\/div>' +
            '<div id="preloader-bar1">' +
              '<div id="preloader-bar2"><\/div>' +
            '<\/div>' +
            '<div id="preloader-round"><\/div>' +
            '<div id="preloader-items"><\/div>' +
            '<div id="preloader-total">Loading...<\/div>' +
            '<div id="preloader-percent">0%<\/div>' +
          '<\/div>'
        );
        GAME.$preloader = $("#preloader");
        GAME.preloader.$area = $("#preloader-area");
        GAME.preloader.$bar1 = $("#preloader-bar1");
        GAME.preloader.$bar2 = $("#preloader-bar2");
        GAME.preloader.$items = $("#preloader-items");
        GAME.preloader.$percent = $("#preloader-percent");
        GAME.preloader.$total = $("#preloader-total");
        for (var x = 0; x < b.length; x++)
          GAME.preloader.$items.append('<div class="preloader-item loading"><\/div>');
        GAME.preloader.scroll();
				// GAME.script("scripts/filesize.php?files=" + b.join(","));
				GAME.preloader.init(b.map(fileSizeDotPhp));
      }
      else
        GAME.preloader.complete();
    },
    loaded: function() {
      var finished = new Date().getTime();
      GAME.preloader.totalBytes += GAME.preloader.todo[GAME.preloader.done][1];
      GAME.preloader.totalTime += finished - GAME.preloader.checkpoint;
      GAME.preloader.past.pushUnique(GAME.preloader.todo[GAME.preloader.done][0]);
      GAME.preloader.done++;
      GAME.preloader.checkpoint = finished;

      // start the faux progress bar after the first download
      if (GAME.preloader.done == 1)
        GAME.preloader.faux();
      GAME.preloader.thus += GAME.preloader.todo[GAME.preloader.done - 1][1];
      GAME.preloader.$thus.html(GAME.format(GAME.preloader.thus));
      GAME.preloader.$items.children(".loading:first").removeClass("loading").addClass("loaded");
      var percent = GAME.percent(GAME.preloader.thus, GAME.preloader.total);
      GAME.preloader.$bar2.width(percent);
      GAME.preloader.$percent.html(percent);
      if (GAME.preloader.done == GAME.preloader.todo.length) {
        clearTimeout(GAME.preloader.timeouts[0]); // progress bar animation
        clearTimeout(GAME.preloader.timeouts[1]); // faux progress
        GAME.$preloader.remove();
        GAME.preloader.complete();
      }
      else {
        GAME.preloader.$bar2.css("max-width", GAME.percent(GAME.preloader.thus + GAME.preloader.todo[GAME.preloader.done][1], GAME.preloader.total));
        setTimeout(GAME.preloader.next, GAME.preloader.delay);
      }
    },
    next: function() {
      var src = GAME.preloader.todo[GAME.preloader.done][0];
      if (id = src.match(/\/([\d\-\.\w]+?)\.(?:mid|mp3|ogg|wav)$/)) {
        GAME.debug("Loading sound: " + src);
        if (
          GAME.sound.supported &&
          !soundManager.getSoundById(id[1]) // don't redownload sounds already loaded
        ) {

          // If there is an author, add them to the list of authors to be displayed via notice
          if (author = src.match(/\/by\/([\d\-\.\w]+)\/[\d\-\.\w]+\.(?:mid|mp3|ogg|wav)$/))
            GAME.sound.authors[id[1]] = author[1];
          var temp = soundManager.createSound({
            id: id[1],
            url: src,
            autoLoad: true,
            autoPlay: false,
            onfinish: function() {
              if (this.loop)
                GAME.sound.play(this.sID, true);
            },
            onload: GAME.preloader.loaded,
            volume: GAME.sound.volumeLevel
          });
          temp.loop = true;
        }
        else
          GAME.preloader.loaded();
      }
      else {
        GAME.debug('Loading image: <a href="' + src + '">' + src.replace(new RegExp("^" + GAME.url.replace(/\./g, "\\.").replace(/\//g, "\\/")), "") + '<\/a>');
        var img = document.createElement("img");
        img.onload = GAME.preloader.loaded;
        img.setAttribute("src", src);
        GAME.preloader.$area.append(img);
      }
    },
    past: [],
    quick: function() {
      // GAME.debug("Starting quick preloader.");
      GAME.preloader.todo = [];
      var callback = null;
      for (var x = 0; x < arguments.length; x++) {
        if (typeof(arguments[x]) == "function")
          callback = arguments[x];
        else if (!GAME.preloader.past.contains(arguments[x]))
          GAME.preloader.todo.push(arguments[x]);
      }

      // Set here instead of for loop, because it must be set (even to null) in order to override any potential pre-existing callbacks.
      // Can't erase callback after calling it, because the called callback may set a new one (such as the map preload character creation callback containing a say box quick load).
      // Erasing the callback post-execution in this case would just erase the new callback before it has a chance to be called.
      GAME.preloader.callback = callback;
      if (GAME.preloader.todo.length) {
        GAME.doing.preload = true;
        GAME.preloader.quickTotal = 0;
        GAME.$gamengine.append(
          '<div id="preloader-area"><\/div>' +
          '<img alt="Loading..." height="16" id="preloader-quick" src="images/preloader/quick7.gif" width="16" />'
        );
        GAME.preloader.$area = $("#preloader-area");
        GAME.preloader.$quick = $("#preloader-quick")
          .css({zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000})
          .slide(GAME.$gamengine.width() / 2 - 8, GAME.$gamengine.height() / 2 - 8);
        for (var x = 0; x < GAME.preloader.todo.length; x++) {
          // needs quick loading sound, too
          GAME.debug('Quick loading image: <a href="' + GAME.preloader.todo[x] + '">' + GAME.preloader.todo[x].replace(new RegExp("^" + GAME.url.replace(/\./g, "\\.").replace(/\//g, "\\/")), "") + '<\/a>');
          var img = document.createElement("img");
          img.onload = GAME.preloader.quickLoaded;
          img.setAttribute("src", GAME.preloader.todo[x]);
          GAME.preloader.$area.append(img);
        }
      }
      else
        GAME.preloader.complete();
    },
    quickLoaded: function() {
      GAME.preloader.past.push(GAME.preloader.todo[GAME.preloader.quickTotal]);
      GAME.preloader.quickTotal++;
      if (GAME.preloader.quickTotal == GAME.preloader.todo.length) {
        //setTimeout(function(){
        GAME.preloader.$area.remove();
        GAME.preloader.$quick.remove();
        GAME.preloader.complete();
        //},2500);
      }
    },
    quickTotal: 0,
    scroll: function(){
      GAME.preloader.$bar1.scroll(2, 0);
      GAME.preloader.$bar2.scroll(2, 0);
      GAME.preloader.timeouts[0] = setTimeout(
        GAME.preloader.scroll,
        100
      );
    },
    started: 0,
    thus: 0,
    timeouts: [0, 0],
    todo: [],
    total: 0,
    totalBytes: 0,
    totalTime: 0
  },
  random: function(min, max) {
    if (typeof(max) == "undefined") {
      max = min;
      min = 0;
    }
    return Math.floor(Math.random() * (max - min + 1)) + min;
  },
  say: function(id, message, offset) {
    // No interrupting!
    if (GAME.is("choice", "message"))
      return setTimeout(
        function() {
          GAME.say(id, message, offset);
        },
        100
      );

    $(".say-" + id).remove();
    if (typeof(message[offset * 2]) == "string") {
      GAME.preloader.quick(
        GAME.url + "images/say/corner/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
        GAME.url + "images/say/horizontal/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
        GAME.url + "images/say/stem/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
        GAME.url + "images/say/vertical/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
        function() {
          var stem = id == 0 || GAME.characters[0].position[0] < GAME.characters[id].position[0] ? "left" : "right";
          GAME.$gamengine.append(
            '<div class="say say-' + id + '">' +
              '<div class="horizontal top"><\/div>' +
              '<span class="text">' + message[offset * 2] + '<\/span>' +
              '<div class="vertical left"><\/div>' +
              '<div class="vertical right"><\/div>' +
              '<div class="horizontal bottom"><\/div>' +
              '<div class="corner one"><\/div>' +
              '<div class="corner two"><\/div>' +
              '<div class="corner three"><\/div>' +
              '<div class="corner four"><\/div>' +
              '<div class="stem ' + stem + '"><\/div>' +
            '<\/div>'
          );
          var $say = $(".say-" + id);
          var $sayText = $say.children(".text");
          // Pythagorean Theorum (a^2 + b^2 = c^2; c = SqRt(a^2 + b^2)
          // distance between the two characters = square root of horizontal difference squared plus vertical difference squared
          var a = GAME.characters[1].position[0] - GAME.characters[0].position[0],
            b = GAME.characters[1].position[1] - GAME.characters[0].position[1],
            c = Math.round(GAME.$gamengine.width() / GAME.map.maps[GAME.map.current].block),
            d = Math.round(GAME.$gamengine.height() / GAME.map.maps[GAME.map.current].block);
          $sayText.css(
            "font-size",
            (14 - Math.round(Math.sqrt(a * a + b * b) / Math.round(Math.sqrt(c * c + d * d)) * 10)) + "px"
          );
          $say.children(".horizontal").width($sayText.width() - 1);
          $say.children(".vertical").height($sayText.height() - 1);
          //$say.children(".vertical.right").slide($sayText.width() + 6, 0);
          $say.css({
            left: (

              // center of the screen
              320 +

              // number of blocks away from the player
              (GAME.characters[id].position[0] - GAME.characters[0].position[0]) * GAME.map.maps[GAME.map.current].block +

              // player's offset (when walking)
              GAME.characters[0].offset[0] +

              // character's offset (when walking)
              GAME.characters[id].offset[0] -

              // half the text box
              ($sayText.width() + 11) / 2 +

              // Move stem to side of player.
              (stem == "left" ? -1 : 1) * GAME.characters[id].width
            ).toString() + "px",
            marginBottom: "-" + ($sayText.height() + 12).toString() + "px",
            top: (

              // center of the screen
              (240 - Math.round(GAME.characters[id].height / 2) + GAME.characters[id].offset[1]) +

              // offset for non-players by the number of blocks away from the player
              (id == 0 ? 0 : (GAME.characters[id].position[1] - GAME.characters[0].position[1]) * GAME.map.maps[GAME.map.current].block) +

              // offset for walking player
              GAME.characters[0].offset[1] -

              // offset by height of text box
              $sayText.height() - 37
            ).toString() + "px",
            zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
          }).height($sayText.height() + 11).width($sayText.width() + 11);

          // offset by half textbox and stem
          $say.children(".stem").css("left", ($say.width() / 2 - (stem == "left" ? 11 : GAME.characters[id].width / 2)) + "px");
          $sayText.css({
            backgroundColor: "#" + GAME.characters[id].background,
            color: "#" + GAME.characters[id].foreground
          });
          var shapes = ["corner", "horizontal", "stem", "vertical"];
          for (var x = 0; x < 4; x++)
            $(".say ." + shapes[x]).css("background-image", 'url("' + GAME.url + 'images/say/' + shapes[x] + '/' + GAME.characters[id].background + '-' + GAME.characters[id].foreground + '.gif")');
          if (typeof(message[offset * 2 + 1]) == "number")
            GAME.characters[id].timeouts.say = setTimeout(
              function() {
                GAME.say(id, message, offset + 1);
              },
              message[offset * 2 + 1]
            );
        }
      );
    }
    else if (typeof(message[offset * 2]) == "function") {
      GAME.debug("Executing say callback.");
      message[offset * 2]();
    }
  },
  script: function(url, id) {
    GAME.debug('<a href="' + GAME.url + url + '">' + url + '<\/a>');
    if (
      typeof(id) == "string" &&
      document.getElementById(id)
    )
      GAME.$head.remove("#" + id);
    var temp = document.createElement("script");
    temp.setAttribute("src", GAME.url + url);
    temp.setAttribute("type", "text/javascript");
    temp.onload = function() {
      GAME.$head.remove(this);
    };
    GAME.$head.append(temp);
  },
  settings: {},
  sound: {
    authors: {},

    // Calling this crashes everything.
    destroy: function() {
      while (soundManager.soundIDs.length) {
        GAME.debug("Destroying sound: " + soundManager.soundIDs[0]);
        soundManager.destroySound(soundManager.soundIDs[0]);
      }
    },
    enabled: false,
    mute: function() {
      if (GAME.sound.supported) {
        GAME.sound.enabled = false;
        soundManager.mute();
        GAME.debug("Muted.");
      }
    },
    play: function(id, loop) {
      if (
        GAME.sound.supported &&
        soundManager.getSoundById(id).playState != 1
      ) {
        soundManager.play(id);
        if (typeof(loop) != "undefined") {
          if (
            !loop &&
            soundManager.getSoundById(id)
          )
            soundManager.getSoundById(id).loop = false;
        }

        // only debug music that loops (not sound effects) and only on the first play
        else {
          GAME.debug("Playing " + id);
          if (id in GAME.sound.authors)
            GAME.preloader.quick(
              "images/notice/music/000000.gif",
              function() {
                GAME.notice(
                  '<img alt="Music" height="12" src="images/notice/music/000000.gif" width="13" /> &nbsp; ' +
                  '&quot;' + id.replace(/\_/g, " ") + '&quot; by ' + GAME.sound.authors[id].replace(/\_/g, " ")
                );
              }
            );
        }
      }
    },
    ready: function() {
      GAME.debug("Sound Manager loaded.");
      GAME.sound.enabled = true;
      GAME.sound.supported = true;
      GAME.debug("Engine starting.");
      GAME.start();
    },
    stop: function() {
      for (var x = 0; x < soundManager.soundIDs.length; x++)
        soundManager.getSoundById(soundManager.soundIDs[x]).stop();
    },
    supported: false,
    timeout: function() {
      GAME.debug('<strong class="error">Error loading Sound Manager.</strong>');
      GAME.sound.enabled = false;
      GAME.sound.supported = false;
      GAME.start();
    },
    unmute: function() {
      if (GAME.sound.supported) {
        GAME.sound.enabled = true;
        soundManager.unmute();
        GAME.debug("Unmuted.");
      }
    },
    volume: function(x) {
      var temp = GAME.sound.volumeLevel;
      GAME.sound.volumeLevel += x;
      GAME.sound.volumeLevel = Math.min(Math.max(GAME.sound.volumeLevel, 0), 100);
      if (GAME.sound.volumeLevel != temp) {
        GAME.debug((x < 0 ? "De" : "In") + "creasing volume to " + GAME.sound.volumeLevel + "%.");
        for (var x = 0; x < soundManager.soundIDs.length; x++)
          soundManager.setVolume(soundManager.soundIDs[x], GAME.sound.volumeLevel);
      }
    },
    volumeLevel: 100
  },
  start: null,
  timeOfDay: function(numeric) {
    if (typeof(numeric) == "undefined")
      var numeric = false;
    var hour = new Date().getHours();
    // night (12, 1, 2, 3) -> dawn (4, 5, 6, 7) -> day (8, 9, 10, 11, 12, 1, 2, 3) -> evening (4, 5, 6, 7) -> night (8, 9, 10, 11)
    return (
      hour >= 4 &&
      hour < 8 ?
      numeric ? 66 : 'dawn' :
      hour >= 8 &&
      hour < 16 ?
      numeric ? 75 : 'day' :
      hour >= 16 &&
      hour < 20 ?
      numeric ? 66 : 'dusk' :
      numeric ? 33 : 'night'
    );
  },
  timeouts: {},
  url: ""
};

GAME.start = function() {
  GAME.load({
    character: {
      character: "Red",
      facing: 3,
      name: "Charles Stover",
      position: [2, 6]
      // pallet: [16, 14]
      // room1: [2, 6]
    },
    map: "room1",
    multiplayer: true
  });
}

window["soundManager"]["debugMode"] = false;
window["soundManager"]["flashVersion"] = 8;
window["soundManager"]["onready"](GAME.sound.ready);
window["soundManager"]["ontimeout"](GAME.sound.timeout);
window["soundManager"]["url"] = "scripts/";
window["soundManager"]["useFlashBlock"] = false;