/*********************************************\
|*                                           *|
|*   Copyright © 2011-2012, Charles Stover   *|
|*            All Rights Reserved            *|
|*                                           *|
\*********************************************/

Array.prototype.contains = function(needle)
{
	if (typeof(needle) == "object")
	{
		for (var x = 0; x < needle.length; x++)
		{
			if (this.contains(needle[x]))
				return true;
		}
		return false;
	}
	for (var x = 0; x < this.length; x++)
	{
		if (this[x] === needle)
			return true;
	}
	return false;
};

Array.prototype.pushUnique = function(needle)
{
	if (!this.contains(needle))
		this.push(needle);
	return this;
};

Array.prototype.remove = function(needle)
{
	for (var x = 0; x < this.length; x++)
	{
		if (this[x] === needle)
		{
			this.splice(x, 1);
			x--;
		}
	}
	return this;
};

$["fn"].boxShadow = function(xOffset, yOffset, blurRadius, shadowColor)
{
	// Created by Martin Hintzmann 2008 martin [a] hintzmann.dk
	// MIT (http://www.opensource.org/licenses/mit-license.php) licensed.
	if (!$.browser.msie)
		return this;
	return this.each(
		function()
		{
			$(this).css({
				position: "relative",
				zoom: 1,
				zIndex: "2"
			});
			$(this).parent().css("position", "relative");
			var temp = document.createElement("div");
			$(this).parent().append(temp);
			var _height = $(this).outerHeight(),
				_left = xOffset,
				_top = yOffset,
				_width = $(this).outerWidth();
			if (blurRadius != 0)
			{
				$(temp).css("filter", "progid:DXImageTransform.Microsoft.Blur(pixelRadius=" + blurRadius + ", enabled='true')");
				_height += 1;
				_left -= blurRadius + 1;
				_top -= blurRadius + 1;
				_width += 1;
			}
			$(temp).css({
				backgroundColor: shadowColor,
				height: _height + "px",
				left: _left + "px",
				position: "absolute",
				top: _top + "px",
				width: _width + "px",
				zIndex: 1
			});
		}
	);
};

$["fn"].scroll = function(x, y, w, h)
{
	var bp = this.css("background-position") || "0 0";
	var bp = bp.match(/^(\-?[\d\.]+)(?:px)?\s+(\-?[\d\.]+)(?:px)?$/);
	bp[1] = parseFloat(bp[1]);
	bp[2] = parseFloat(bp[2]);
	if (typeof(w) == "number")
	{
		if (bp[1] > w)
			bp[1] -= w;
		else if (bp[1] < -1 * w)
			bp[1] += w;
	}
	if (typeof(h) == "number")
	{
		if (bp[2] > h)
			bp[2] -= h;
		else if (bp[2] < -1 * h)
			bp[2] += h;
	}
	return this.scrollTo(bp[1] + x, bp[2] + y);
};

$["fn"].scrollTo = function(x, y)
{
	return this.css("background-position", x + "px " + y + "px");
};

$["fn"].slide = function(x, y)
{
	if (this.length)
	{
		var left = this.css("left"),
			top = this.css("top");
		left = parseFloat((left == "auto" ? "0" : left).match(/^(\-?[\d\.]+)(?:px)?/)[1]);
		top = parseFloat((top == "auto" ? "0" : top).match(/^(\-?[\d\.]+)(?:px)?/)[1]);
		return this.slideTo(left + x, top + y);
	}
};

$["fn"].slideTo = function(x, y)
{
	return this.css({
		left: x + "px",
		top: y + "px"
	});
};

var GAME = {
	$debug: $("#debug > div"),
	$debugWrapper: $("#debug"),
	$document: $(document),
	$gamengine: $("#gamengine"),
	$head: $("head"),
	$notice: null,
	$preloader: null,
	$window: $(window),
	callbacks: {},

	// create a character
	character: function(o, p)
	{

		// Is the character the player?
		p = typeof(p) != "undefined" ? p : false;

		GAME.debug("Creating " + (p ? "player" : "character #" + GAME.characters.length) + (typeof(o.character) != "undefined" ? ": " + o.character : "."));

		// Create the character's object.
		// Unless that character is the player and the player has already been created (no need to recreate, and may cause error if character object changes during this function's execution).
		if (
			typeof(p) != "number" ||
			!(0 in GAME.characters) ||
			!("direction" in GAME.characters[0])
		)
			o = $.extend(
				true,
				{
					background: "ffffff",
					callbacks: {},
					canBeInvisible: false,
					character: "NPC",
					cooldowns: {},
					direction: [],
					directionForce: [],

					// Update step sprite.
					displayStep: function()
					{
						GAME.functions.displayStep(this.id);
					},
					facePlayer: function()
					{
						GAME.functions.facePlayer(this.id);
					},
					facing: 4,
					foot: 0,
					foreground: "000000",
					height: 16,
					image: "none",
					invisible: false,
					loaded: null,
					message: function()
					{
						var temp = [this.id];
						for (var x = 0; x < arguments.length; x++)
							temp.push(arguments[x]);
						GAME.message(temp);
						delete temp;
					},
					name: "Anonymous",
					offset: [0, 0],
					position: [0, 0],
					running: false,
					say: function()
					{
						GAME.say(this.id, arguments, 0);
					},
					speed: {
						run: 500,
						walk: 1000
					},
					step: function()
					{
						for (var x = 0; x < arguments.length; x++)
						{
							if (typeof(arguments[x]) == "function")
								this.callbacks.step = arguments[x];
							else
								this.directionForce.unshift(arguments[x]);
						}
						GAME.functions.step(this.id);
					},

					// force stop walking
					stop: function()
					{
						this.direction = [];

						// Disabling running here will disable running when no arrow keys are pressed, even if run key is still held, which will disable running whenever arrow keys are pressed again.
						// this.running = false;

						// If they're on an odd step, go to the next feet-together pose.
						if (this.foot % 2)
							this.foot = (this.foot + 1) % 4;

						// Display feet together.
						this.$.scrollTo(0, (4 - this.facing) * -1 * this.height);
					},
					timeouts: {},
					width: 16
				},

				// Default character settings.
				typeof(o.character) != "undefined" &&
				typeof(GAME.characterSettings[o.character]) != "undefined" ?
				GAME.characterSettings[o.character] :
				{},

				// Custom character settings.
				o
			);
		o.id = typeof(p) == "number" ? 0 : GAME.characters.length;

		// create the character's element
		var append = '<div class="character" id="character-' + o.id + '"><\/div>';
		if (typeof(p) == "number")
			GAME.$gamengine.append(append);
		else
			GAME.characters[0].$.after(append);
		o.$ = $("#character-" + o.id);

		// position the character
		GAME.preloader.quick(
			GAME.url + "images/characters/" + GAME.timeOfDay(true) + "/" + o.image,
			function()
			{
				o.$.css({
					backgroundImage: o.image == "none" ? "none" : 'url("' + GAME.url + 'images/characters/' + GAME.timeOfDay(true) + '/' + o.image + '")',
					backgroundPosition: "0 " + (4 - o.facing) * -1 * o.height + "px",
					height: o.height.toString() + "px",
					left: (

						// center of the screen
						(320 - Math.round(o.width / 2) + o.offset[0]) +

						// offset for non-players by the number of blocks away from the player
						(typeof(p) == "number" ? 0 : (o.position[0] - GAME.characters[0].position[0]) * GAME.map.maps[GAME.map.current].block)
					).toString() + "px",
					marginBottom: "-" + o.height.toString() + "px",
					top: (

						// center of the screen
						(240 - Math.round(o.height / 2) + o.offset[1]) +

						// offset for non-players by the number of blocks away from the player
						(typeof(p) == "number" ? 0 : (o.position[1] - GAME.characters[0].position[1]) * GAME.map.maps[GAME.map.current].block)
					).toString() + "px",
					width: o.width.toString() + "px",
					zIndex: (

						// Place the player at 1000 per overlay.
						typeof(p) == "number" ?
						p :

						// Main character's overlay
						Math.floor(parseFloat(GAME.characters[0].$.css("z-index").toString().match(/[\-\d]+/)[0]) / 1000)
					) * 1000 + o.position[1]
				});

				// Store the character.
				GAME.characters[o.id] = o;

				// Function to run on load.
				if (typeof(GAME.characters[o.id].loaded) == "function")
				{
					GAME.debug("Executing character callback.");
					GAME.characters[o.id].loaded(o.id);
				}
			}
		);
		return o.id;
	},
	characters: [{}],
	characterSettings: {
		Grandma: {
			background: "c0c0c0",
			foreground: "000000",
			height: 21,
			image: "pokemon/grandma.gif",
			offset: [0, -2],
			speed: {
				run: null,
				walk: 750
			},
			width: 16
		},
		Janus: {
			height: 24,
			image: "chrono-trigger/janus.gif",
			offset: [0, -2],
			speed: {
				run: null,
				walk: 250
			},
			width: 14
		},
		Leaf: {
			background: "d8ffd8",
			foreground: "000000",
			height: 21,
			image: "pokemon/leaf.gif",
			offset: [0, -2],
			speed: {
				run: 150,
				walk: 250
			},
			width: 16
		},
		Red: {
			height: 21,
			image: "pokemon/red.gif",
			offset: [0, -2],
			speed: {
				run: 150,
				walk: 250
			},
			width: 16
		},
		Schala: {
			height: 31,
			image: "chrono-trigger/schala.gif",
			offset: [0, -2],
			speed: {
				run: null,
				walk: 250
			},
			width: 16
		},
		Tata: {
			height: 24,
			image: "chrono-trigger/tata.gif",
			offset: [-1, -2],
			speed: {
				run: null,
				walk: 250
			},
			width: 18
		},
		Toma: {
			height: 32,
			image: "chrono-trigger/toma.gif",
			offset: [-1, -2],
			speed: {
				run: null,
				walk: 250
			},
			width: 18
		}
	},
	choice: function()
	{
		if (!GAME.is("message", "preload"))
		{
			GAME.doing.choice = true;
			GAME.callbacks.choice = arguments[arguments.length - 1];

			// store all messages
			GAME.data.choices = [];
			for (var x = 0; x < arguments.length - 1; x++)
				GAME.data.choices.push(arguments[x]);

			GAME.debug("Creating choice menu: " + GAME.data.choices.join(", "));

			// the choice element
			var $message = $(document.createElement("ul"))
				.addClass("choice")
				.css({
					zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
				})
				.html(
					'<li class="selected">' + GAME.data.choices.join('</li><li>') + '</li>'
				);
			GAME.$gamengine.append($message);
			return true;
		}
		return false;
	},
	credits: function(music)
	{
		GAME.doing.preload = true;
		GAME.$gamengine.empty();
		GAME.$gamengine.append('<div id="credits"><\/div>');
		GAME.credit = 0;
		GAME.$credits = $("#credits");
		GAME.$$credits = [];
		GAME.map.clearTimeouts();
		GAME.sound.stop();
		GAME.sound.play(music);
		for (var x = 1; x < arguments.length; x++)
		{
			GAME.$credits.append('<div id="credits-' + x + '">' + arguments[x] + '<\/div>');
			GAME.$$credits[x - 1] = $("#credits-" + x);
			GAME.$$credits[x - 1].fadeTo(0, 0);
			setTimeout(
				function()
				{
					GAME.$$credits[GAME.credit].css("top", (480 - GAME.$$credits[GAME.credit].height()) / 2 + "px");
					GAME.$$credits[GAME.credit].fadeTo(1000, 1,
						function()
						{
							setTimeout(
								function()
								{
									if (GAME.credit != GAME.$$credits.length - 1)
										GAME.$$credits[GAME.credit].fadeTo(1000, 0,
											function()
											{
												GAME.$$credits[GAME.credit - 1].remove();
											}
										);
									GAME.credit++;
								},
								3000
							);
						}
					);
				},
				5000 * (x - 1)
			);
		}
	},
	data: {},
	debug: function(x)
	{
		if (GAME.doing.debug)
		{
			if (typeof(x) == "object")
			{
				var numeric = 0,
					temp = x,
					total = 0,
					y = [],
					y2 = [];
				for (var z in temp)
				{
					if (typeof(temp[z]) != "function")
					{
						total++;
						if (z.match(/^\d+$/))
						{
							numeric++;
							y2.push(temp[z]);
						}
						y.push(z + ": " + temp[z]);
					}
				}
				if (numeric == total)
					y = y2.join(", ");
				else
					y = y.join(",<br />");
			}
			else if (typeof(x) == "boolean")
				var y = x ? "true" : "false";
			else
				var y = x;
			GAME.$debug.append(y + "<br />");
			GAME.$debug.parent().scrollTop(GAME.$debug.height());
		}
	},
	doing: {
		debug: true,
		interact: false,
		map: false,
		message: false,
		preload: false,
		step: false
	},
	format: function(n)
	{
		n = n.toString();
		var n2 = "";
		for (var x = 0; x < n.length; x++)
			n2 = n.charAt(n.length - 1 - x) + (x > 0 && !(x % 3) ? "," : "") + n2;
		return n2;
	},
	functions: {
		choice: function(direction)
		{

			// selection made
			if (typeof(direction) == "undefined")
			{
				var selection = $(".choice li.selected").html();
				$(".choice").remove();
				GAME.debug("Choice selected: " + selection);
				GAME.callbacks.choice(selection);
				GAME.doing.choice = false;
				return selection;
			}

			if (direction == null)
			{
				$(".choice li.selected").removeClass("selected").siblings().last().addClass("selected");
				return GAME.functions.choice();
			}

			if (typeof(GAME.data.lastChoiceDirection) == "undefined")
				GAME.data.lastChoiceDirection = direction;

			// changed direction without letting up on other key, ignore other key
			else if (GAME.data.lastChoiceDirection != direction)
			{
				GAME.data.lastChoiceDirection = direction;
				clearTimeout(GAME.timeouts.choice);
			}

			var $selected = $(".choice .selected");
			if (direction == 38)
			{
				var $new = $selected.prev();
				if (!$new.length)
					$new = $selected.siblings().last();
			}
			else
			{
				var $new = $selected.next();
				if (!$new.length)
					$new = $selected.siblings().first();
			}
			$selected.removeClass("selected");
			$new.addClass("selected");
			GAME.timeouts.choice = setTimeout(
				function()
				{
					// if last direction key pressed is still active,
					if (GAME.keys.active[GAME.data.lastChoiceDirection])
						GAME.functions.choice(GAME.data.lastChoiceDirection);

					// if they released the last key pressed but are still holding down the other direction,
					else if (GAME.keys.active[GAME.data.lastChoiceDirection == 38 ? 40 : 38])
						GAME.functions.choice(GAME.data.lastChoiceDirection == 38 ? 40 : 38);
				},
				200
			);
			return $new.html();
		},
		direction: {
			down: function(keyCode)
			{
				if (
					typeof(GAME.characters[0]) == "object" &&
					"direction" in GAME.characters[0]
				)
				{
					GAME.characters[0].direction.pushUnique(keyCode);
					if (!GAME.is("preload", "step"))
						GAME.characters[0].step();
				}
			},
			up: function(keyCode)
			{
				if (
					typeof(GAME.characters[0]) == "object" &&
					"direction" in GAME.characters[0]
				)
					GAME.characters[0].direction.remove(keyCode);
			}
		},
		displayStep: function(id)
		{
			GAME.characters[id].$.scrollTo(
				(
					(GAME.characters[id].running ? 3 : 0) + // running sprites are 3 spots over on the sprite sheet
					GAME.characters[id].foot % 2 + // step 0 and 2 at position 0
					(GAME.characters[id].foot == 3 ? 1 : 0) // step 3 at position 2 (step % 2 + 1)
				) * -1 * GAME.characters[id].width,
				(
					4 - GAME.characters[id].facing // starting at 4 (below sprite sheet), move up 1 for each direction
				) * -1 * GAME.characters[id].height
			);
		},
		enter: function(x, y)
		{

			// Get the function.
			var enter = GAME.map.maps[GAME.map.current].enter[y + 1][x + 1];
			if (typeof(enter) == "object")
				enter = enter[GAME.characters[0].facing - 1];

			// If the entrance is a string, make it a function.
			if (typeof(enter) == "string")
				enter = GAME.map.maps[GAME.map.current].functions[enter];

			// If an entrance exists,
			if (typeof(enter) == "function")
			{

				// Force stop running.
				//GAME.characters[0].running = false;

				// Force stop walking.
				//GAME.characters[0].stop();

				// Execute the function.
				enter();
				return true;
			}
			return false;
		},
		facePlayer: function(id)
		{
			// 1>3, 2>4, 3>1, 4>2
			GAME.characters[id].facing = GAME.characters[0].facing + (GAME.characters[0].facing < 3 ? 2 : -2);
			GAME.characters[id].displayStep();
		},
		interact: function()
		{
			if (!GAME.is("interact", "preload"))
			{

				// Check character interactions.
				for (var x = 1; x < GAME.characters.length; x++)
				{
					if (
						// 1>-1, 2>0, 3>1, 4>0
						GAME.characters[x].position[0] == Math.round(GAME.characters[0].position[0] - Math.sin(GAME.characters[0].facing * Math.PI / 2)) &&
						// 1>0, 2>-1, 3>0, 4>1
						GAME.characters[x].position[1] == Math.round(GAME.characters[0].position[1] + Math.cos(GAME.characters[0].facing * Math.PI / 2)) &&
						typeof(GAME.characters[x].interaction) == "function"
					)
					{

						// Force stop running.
						// GAME.characters[0].running = false;

						// Force stop walking.
						GAME.characters[0].stop();

						// Execute the interaction.
						GAME.doing.interact = GAME.characters[x].interaction();
						if (typeof(GAME.doing.interact) == "undefined")
							GAME.doing.interact = false;
						return true;
					}
				}

				// Get the interaction.
				var interaction = GAME.map.maps[GAME.map.current].interaction,
					y = Math.round(GAME.characters[0].position[1] + 1 + Math.cos(GAME.characters[0].facing * Math.PI / 2)); // 0.999... fffffffuuuuuuuuuuuu

				// If we're in a defined vertical area of the map,
				if (y in interaction)
				{
					interaction = interaction[y];

					// If we're in a defined horizontal area of the map,
					var x = Math.round(GAME.characters[0].position[0] + 1 + Math.sin(GAME.characters[0].facing * Math.PI / 2) * -1); // 0.999... fffffffuuuuuuuuuuuu
					if (x in interaction)
					{
						interaction = interaction[x];

						// If the interaction is directional,
						if (typeof(interaction) == "object")

							// 1>2, 2>3, 3>0, 4>1
							interaction = interaction[GAME.characters[0].facing + (GAME.characters[0].facing > 2 ? -3 : 1)];

						// If an interaction exists,
						if (typeof(interaction) == "function")
						{

							// Force stop running.
							// GAME.characters[0].running = false;

							// Force stop walking.
							GAME.characters[0].stop();

							// Execute the interaction.
							GAME.doing.interact = interaction();
							if (typeof(GAME.doing.interact) == "undefined")
								GAME.doing.interact = false;
							return true;
						}
					}
				}
			}
			return false;
		},
		step: function(id)
		{
			var direction = null;

			// If a direction is being forced,
			if (typeof(GAME.characters[id].directionForce[0]) != "undefined")
			{
				if (!GAME.is("choice", "message", "preload"))
					direction = GAME.characters[id].directionForce.pop();
			}

			// Main character's manual steps.
			else
			{

				// Don't step if...
				if (!GAME.is("choice", "message", "preload", "step"))
				{
					GAME.doing.step = true;

					// Calculate direction of travel.
					direction = GAME.characters[0].direction[GAME.characters[0].direction.length - 1];
					direction = [37, 65].contains(direction) ? 1 :
						[38, 87].contains(direction) ? 2 :
						[39, 68].contains(direction) ? 3 :
						4;
				}
			}

			if (direction != null)
			{

				// Calculate direction.
				GAME.characters[id].facing = direction;

				// Step
				GAME.characters[id].foot = (GAME.characters[id].foot + 1) % 4;

				/*
				// Only footsteps when running.
				if (
					GAME.characters[0].running &&
					GAME.characters[0].foot % 2 == 0
				)
					GAME.characters[0].foot++;
				/**/

				// Display step.
				GAME.characters[id].displayStep();

				// Calculate new position.
				var position = [
					GAME.characters[id].position[0] + (direction == 1 ? -1 : (direction == 3 ? 1 : 0)),
					GAME.characters[id].position[1] + (direction == 2 ? -1 : (direction == 4 ? 1 : 0))
				];

				// Is the position blocked?
				var blocked = GAME.map.maps[GAME.map.current].blocked;
				if (typeof(blocked[position[1] + 1]) == "object")
				{
					blocked = blocked[position[1] + 1][position[0] + 1];
					if (typeof(blocked) == "object")
						blocked = blocked[(direction + 1) % 4];
				}
				else
					blocked = 1;
				for (var x = 0; x < GAME.characters.length; x++)
				{
					if (
						GAME.characters[x].position[0] == position[0] &&
						GAME.characters[x].position[1] == position[1]
					)
					{
						blocked = 1;
						break;
					}
				}

				// If the position isn't blocked,
				if (!blocked)
				{

					// Update z-index
					GAME.characters[id].$.css("z-index", Math.floor(parseFloat(GAME.characters[id].$.css("z-index").toString().match(/[\-\d]+/)[0]) / 1000) * 1000 + position[1]);

					// Direction of scroll.
					// COS: 0=> 1, 1=> 0, 2=>-1, 3=> 0, 4=> 1
					// SIN: 0=> 0, 1=> 1, 2=> 0, 3=>-1, 4=> 0
					var u = direction * Math.PI / 2,
						x = 0, y = 0;

					// Player X:   1=> 1, 2=> 0, 3=>-1, 4=> 0
					// Player Y:   1=> 0, 2=> 1, 3=> 0, 4=>-1
					if (id == 0)
					{
						x = Math.sin(u);
						y = -1 * Math.cos(u);
					}

					// NPC X:      1=>-1, 2=> 0, 3=> 1, 4=> 0
					// NPC Y:      1=> 0, 2=>-1, 3=> 0, 4=> 1
					else
					{
						x = -1 * Math.sin(u);
						y = Math.cos(u);
					}
					x = Math.round(x);
					y = Math.round(y);

					// Update position.
					GAME.characters[id].position = [position[0], position[1]];

					// Characters are now [block] pixels away from their position.
					GAME.characters[id].offset[0] += GAME.map.maps[GAME.map.current].block * x * -1;
					GAME.characters[id].offset[1] += GAME.map.maps[GAME.map.current].block * y * -1;

					// Animate
					for (var z = 0; z < GAME.map.maps[GAME.map.current].block; z++)
					{

						// For the main character, scroll everything except the main character.
						if (id == 0)
						{
							setTimeout(
								function()
								{

									// Set the pixel offset of the main character (and thus the screen)
									GAME.characters[0].offset[0] += x;
									GAME.characters[0].offset[1] += y;

									// For each overlay,
									var overlays = GAME.map.maps[GAME.map.current].overlays; 
									for (var a = 0; a < overlays.length; a++)
									{

										// Excluding the character,
										if (typeof(overlays[a]) == 'object')

											// Scroll the overlay.
											// Shift by the new direction times parallax
											overlays[a].$.scroll(

												// 1->1, 2->0, 3->-1, 4->0
												overlays[a].parallax[0] * x,

												// 1->0, 2->1, 3->0, 4->-1
												overlays[a].parallax[1] * y
											);
									}

									// For each say box,
									$(".say:not(.say-0)").slide(x, y);

									// Scroll each NPC,
									for (var a = 1; a < GAME.characters.length; a++)
										GAME.characters[a].$.slide(x, y);
								},
								z * GAME.characters[0].speed[GAME.characters[0].running ? "run" : "walk"] / GAME.map.maps[GAME.map.current].block
							);
						}

						// For NPCs, scroll just the NPC.
						else
						{
							var temp = "step" + z;
							GAME.characters[id].timeouts[temp] = setTimeout(
								function()
								{

									// Set the offset so that the say box can follow them.
									GAME.characters[id].offset[0] += x;
									GAME.characters[id].offset[1] += y;

									// Slide the character.
									GAME.characters[id].$.slide(x, y);

									// Slide the say box.
									$(".say-" + id).slide(x, y);
								},
								z * GAME.characters[id].speed[GAME.characters[id].running ? "run" : "walk"] / GAME.map.maps[GAME.map.current].block
							);
							delete temp;
						}
					}

					// Finish movement and move the character's position.
					// GAME.doing.step = false; is both here and in the else statement to ensure that it runs prior to enter(), so that enter functions that measure step know that the step has completed.
					// While step will always be false for an enter function, an enter function may still measure step because the function may also be used outside of enter(), such as a map function.
					if (id == 0)
						setTimeout(
							"GAME.doing.step = false; GAME.functions.enter(" + position[0] + ", " + position[1] + ");",
							GAME.characters[0].speed[GAME.characters[0].running ? "run" : "walk"]
						);
				}

				// Main character is blocked.
				else if (id == 0)
					setTimeout(
						"GAME.doing.step = false;",
						GAME.characters[0].speed[GAME.characters[0].running ? "run" : "walk"]
					);

				// NPC is blocked
				else
					GAME.characters[id].directionForce.push(direction);
			}
			GAME.characters[id].timeouts.step = setTimeout(
				function()
				{

					// Definitely display movement sprites when waiting!
					// This also erroneously removes characters[0].direction when preloading.
					// Waiting on something, don't display movement sprites.
					//if (direction == null)
					//	GAME.characters[id].stop();

					// If the character is still walking, step again.
					if (
						GAME.characters[id].direction.length ||
						GAME.characters[id].directionForce.length
					)
						GAME.characters[id].step();

					// Otherwise, stop the animation.
					else
					{
						GAME.characters[id].stop();
						if (typeof(GAME.characters[id].callbacks.step) == "function")
						{
							// GAME.debug("Executing step callback for character #" + id + ".");
							GAME.characters[id].callbacks.step();
						}
					}
				},
				(direction == null ? 50 : GAME.characters[id].speed[GAME.characters[id].running ? "run" : "walk"])
			);
		}
	},
	is: function()
	{
		for (var x = 0; x < arguments.length; x++)
		{
			if (
				typeof(GAME.doing[arguments[x]]) == "boolean" &&
				GAME.doing[arguments[x]]
			)
				return true;
		}
		return false;
	},
	keys: {
		active: [],
		binds: {
			down: {
				// enter
				13: function()
				{
					if (GAME.is("choice"))
						return GAME.functions.choice();
					else if (GAME.is("message"))
						return GAME.message();
					else
					{
						GAME.choice(
							"Controls",
							"Save",
							"Options",
							"Reset",
							"Close",
							function(a)
							{
								if (a == "Controls")
									GAME.message(
										"Arrow keys allow you to move.",
										"Hold S to run.",
										"Press D to interact with people, your environment, and messages.",
										"Press 0 to mute or unmute the game.",
										"Press - to decrease and = to increase the volume.",
										"Press R to reload the game.",
										"Press Enter to open the menu."
									);
								else if (a == "Save")
									GAME.message("Saving has not been programmed yet.");
								else if (a == "Options")
									GAME.message("Options have not been programmed yet.");
								else if (a == "Reset")
									location.reload();
							}
						);
					}
				},
				// space
				32: function()
				{
					if (GAME.is("choice"))
						return GAME.functions.choice();
				},
				// left
				37: function(e)
				{
					return GAME.functions.direction.down(e);
				},
				// up
				38: function(e)
				{
					if (GAME.is("choice"))
						return GAME.functions.choice(38);
					return GAME.functions.direction.down(e);
				},
				// right
				39: function(e)
				{
					return GAME.functions.direction.down(e);
				},
				// down
				40: function(e)
				{
					if (GAME.is("choice"))
						return GAME.functions.choice(40);
					return GAME.functions.direction.down(e);
				},
				// 0
				48: function(e)
				{
					if (GAME.sound.enabled)
						GAME.sound.mute();
					else
						GAME.sound.unmute();
				},
				/* a
				65: function(e)
				{
					return GAME.functions.direction.down(e);
				}, */
				// d
				68: function(e)
				{

					// Respond to an message window.
					if (GAME.is("message"))
						GAME.message();

					else if (GAME.is("choice"))
						GAME.functions.choice();

					// No message window.
					else
					{
						GAME.functions.interact();

						// Force unpress, since browser won't signal unpress during certain interactions, such as message().
						GAME.keys.up({keyCode: 68});
					}
				},
				// r
				82: function(e)
				{
					window.location.reload();
				},
				// s
				83: function(e)
				{
					if (typeof(GAME.characters[0].speed.run) == "number")
						GAME.characters[0].running = true;

					// Cancel choice selection.
					if (GAME.is("choice"))
						GAME.functions.choice(null);
					else if (GAME.is("message"))
						GAME.message();
					else
					{

						// Phantom
						if (GAME.characters[0].character == "Phantom")
						{

							// Not on cooldown.
							if (GAME.characters[0].canBeInvisible)
							{
								GAME.characters[0].invisible = true;
								GAME.characters[0].displayStep();

								// Force release of run key.
								GAME.timeouts.phantomInvisible = setTimeout("GAME.keys.up({keyCode: 83});", GAME.characters[0].speed.invisibility);
							}
						}
					}
				},
				/* s
				83: function(e)
				{
					return GAME.functions.direction.down(e);
				}, */
				/* w
				87: function(e)
				{
					return GAME.functions.direction.down(e);
				},*/
				// numpad 0
				96: function()
				{
					if (GAME.sound.enabled)
						GAME.sound.mute();
					else
						GAME.sound.unmute();
				},
				// =
				187: function(e)
				{
					GAME.sound.volume(25);
				},
				// -
				189: function(e)
				{
					GAME.sound.volume(-25);
				}
			},
			up: {
				/* space
				32: function()
				{
					GAME.characters[0].running = false;
				}, */
				// left
				37: function(e)
				{
					return GAME.functions.direction.up(e);
				},
				// up
				38: function(e)
				{
					if (GAME.is("choice"))
						return clearTimeout(GAME.timeouts.choice);
					return GAME.functions.direction.up(e);
				},
				// right
				39: function(e)
				{
					return GAME.functions.direction.up(e);
				},
				// down
				40: function(e)
				{
					if (GAME.is("choice"))
						return clearTimeout(GAME.timeouts.choice);
					return GAME.functions.direction.up(e);
				},
				/* a
				65: function(e)
				{
					return GAME.functions.direction.up(e);
				}, */
				/* d
				68: function(e)
				{
					return GAME.functions.direction.up(e);
				}, */
				// s
				83: function(e)
				{
					GAME.characters[0].running = false;

					// Phantom
					if (GAME.characters[0].character == "Phantom")
					{
						GAME.characters[0].canBeInvisible = false;
						GAME.characters[0].invisible = false;
						GAME.characters[0].displayStep();
						clearTimeout(GAME.timeouts.phantomInvisible);

						// Set cooldown.
						GAME.map.timeouts.phantomCanBeInvisible = setTimeout("GAME.characters[0].canBeInvisible = true;", GAME.characters[0].cooldowns.invisibility);
					}
				}
				/* s
				83: function(e)
				{
					return GAME.functions.direction.up(e);
				}, */
				/* w
				87: function(e)
				{
					return GAME.functions.direction.up(e);
				} */
			}
		},
		codes: {
			8: "backspace", 9: "tab", 13: "enter", 16: "shift", 17: "ctrl", 20: "capsLock",
			27: "esc", 32: " ", 33: "pageUp", 34: "pageDown", 35: "end", 36: "home",
			37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del",
			48: 0, 49: 1, 50: 2, 51: 3, 52: 4, 53: 5, 54: 6, 55: 7, 56: 8, 57: 9,
			65: "a", 66: "b", 67: "c", 68: "d", 69: "e", 70: "f", 71: "g", 72: "h", 73: "i", 74: "j", 75: "k", 76: "l", 77: "m",
			78: "n", 79: "o", 80: "p", 81: "q", 82: "r", 83: "s", 84: "t", 85: "u", 86: "v", 87: "w", 88: "x", 89: "y", 90: "z",
			91: "windows", 83: "rightClick",
			/* numpad: */ 96: 0, 97: 1, 98: 2, 99: 3, 100: 4, 101: 5, 102: 6, 103: 7, 104: 8, 105: 9,
			107: "=", 109: "-", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6",
			118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "numLk",
			186: ";", 188: ",", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'"
		},
		down: function(e)
		{
			if (!GAME.keys.active[e.keyCode])
			{
				GAME.keys.active[e.keyCode] = true;
				if (typeof(GAME.keys.binds.down[e.keyCode]) == "function")
					GAME.keys.binds.down[e.keyCode](e.keyCode);
			}
		},
		up: function(e)
		{
			GAME.keys.active[e.keyCode] = false;
			if (typeof(GAME.keys.binds.up[e.keyCode]) == "function")
				GAME.keys.binds.up[e.keyCode](e.keyCode);
		}
	},
	onresize: function()
	{
		GAME.$debugWrapper.height(GAME.$window.height() + "px").width((GAME.$window.width() - GAME.$gamengine.width() - 1) / 2 + "px");
		GAME.$gamengine.css("margin-top", ((GAME.$window.height() - GAME.$gamengine.height()) / 2) + "px");
	},
	load: function(settings)
	{

		// callback
		if (typeof(settings.callback) == "function")
			GAME.map.callback = settings.callback;

		// window position
		GAME.onresize();
		GAME.$window.resize(GAME.onresize);

		// load the engine
		/*
		window.SM2_DEFER = true;
		//GAME.preloader.load([
		//	"../scripts/soundmanager2-nodebug-jsmin.js"
		//]);
		var temp = document.createElement("script");
		temp.setAttribute("src", "./scripts/soundmanager2-nodebug-jsmin.js");
		temp.setAttribute("type", "text/javascript");
		temp.onload = function()
		{
			window.soundManager = new SoundManager(); // Flash expects window.soundManager.
			window.soundManager.flashVersion = 8;
			window.soundManager.onready(GAME.sound.ready);
			window.soundManager.ontimeout(GAME.sound.timeout);
			window.soundManager.url = "./scripts/";
			window.soundManager.useFlashBlock = false;
			window.soundManager.beginDelayedInit();
		};
		document.getElementsByTagName("head").item(0).appendChild(temp);
		delete temp;
		*/

		// multiplayer
		if (typeof(settings.multiplayer) != "undefined")
			GAME.multiplayer = settings.multiplayer;

		// main character
		GAME.characters[0] = settings.character;

		// load the map
		GAME.map.load(settings.map, settings.character.position[0], settings.character.position[1]);

		// key down/up
		GAME.$document.keydown(GAME.keys.down);
		GAME.$document.keyup(GAME.keys.up);
	},
	map: {
		callback: null,
		clearTimeouts: function()
		{
			var z = 0;
			for (var x in GAME.map.timeouts)
			{
				z++;
				clearTimeout(GAME.map.timeouts[x]);
				delete GAME.map.timeouts[x];
			}
			GAME.debug("Cleared " + z + " map timeouts.");
			/*if (
				GAME.map.current &&
				typeof(GAME.map.maps[GAME.map.current].timeouts) == "object"
			)
			{
				var t = GAME.map.maps[GAME.map.current].timeouts;
				GAME.debug("Clearing " + t.length + " map timeout" + (t.length != 1 ? "s" : "") + ".");
				for (var x = 0; x < t.length; x++)
					clearTimeout(t[x]);
			}*/
			for (var x = 0; x < GAME.characters.length; x++)
			{
				var z = 0;
				for (var y in GAME.characters[x].timeouts)
				{
					clearTimeout(GAME.characters[x].timeouts[y]);
					z++;
				}
				GAME.debug("Cleared " + z + " timeouts for character #" + x + ".");
			}
		},
		current: null,
		empty: function()
		{
			GAME.debug("Emptying map.");
			GAME.$gamengine.empty();

			// Clear timeouts.
			GAME.map.clearTimeouts();

			// Remove sounds.
			// GAME.sound.destroy();

			// Remove characters.
			for (var x = 1; x < GAME.characters.length; x++)
				GAME.characters.pop();
			// GAME.characters[0].direction = [];
		},
		load: function(name, x, y, music)
		{
			GAME.doing.preload = true;

			// Don't move past the map load command.
			//if ("stop" in GAME.characters[0])
			//	GAME.characters[0].stop();

			if (
				typeof(x) == "number" &&
				typeof(y) == "number"
			)
			{
				GAME.characters[0].position = [x, y];

				// Carry over music to next map.
				// Can't be outside of x/y type check, because new maps downloaded from server run GAME.map.load("name") once download has completed (music parameter always undefined).
				// GAME.sound.stop();
				GAME.data.mapMusic = typeof(music) == "undefined" ? false : true;
			}

			// Only if the map exists,
			if (typeof(GAME.map.maps[name]) == "object")
			{
				GAME.debug("Loading map: <strong>" + name + "</strong>");

				// Remove previous map.
				GAME.map.empty();

				// Set map details.
				GAME.map.current = name;

				GAME.$gamengine.css("background-color", GAME.map.maps[name].color);

				// Preload images for the map.
				GAME.preload(
					function()
					{
						var map = GAME.map.maps[GAME.map.current];

						// Create the overlays.
						// GAME.debug("Creating overlays.");
						for (var i = 0; i < map.overlays.length; i++)
						{

							// Create main character.
							if (typeof(map.overlays[i]) == "boolean")
								GAME.character(GAME.characters[0], i);

							// Create overlay.
							else
							{

								// Default overlay values.
								map.overlays[i] = $.extend(
									{
										$: {},
										offset: [0, 0],
										parallax: [1, 1],
										repeat: "no-repeat"
									},
									map.overlays[i]
								);
								GAME.debug("Creating overlay #" + (i + 1) + ': <a href="' + GAME.url + 'images/maps/' + GAME.timeOfDay(true) + '/' + map.overlays[i].image + '">' + map.overlays[i].image + '<\/a>');
								GAME.$gamengine.append('<div class="overlay" id="overlay-' + (i + 1) + '"><\/div>');
								map.overlays[i].$ = $("#overlay-" + (i + 1));
								map.overlays[i].$.css({
									backgroundImage: 'url("' + GAME.url + 'images/maps/' + GAME.timeOfDay(true) + '/' + map.overlays[i].image + '")',
									backgroundPosition: (312 - GAME.characters[0].position[0] * map.overlays[i].parallax[0] * GAME.map.maps[GAME.map.current].block) + 'px ' +
										(232 - GAME.characters[0].position[1] * map.overlays[i].parallax[1] * GAME.map.maps[GAME.map.current].block) + 'px',
									backgroundRepeat: map.overlays[i].repeat,
									zIndex: i * 1000
								});
							}
						}
						// GAME.debug("Overlays created.");

						// Stop previous map's music.
						if (!GAME.data.mapMusic)
							GAME.sound.stop();

						// Run finish loading function.
						if (typeof(GAME.map.maps[name].loaded) == "function")
							GAME.map.maps[name].loaded();
						GAME.debug("Map loaded.");

						// If player still walking, start walking.
						if (GAME.characters[0].direction.length)
							GAME.characters[0].step();

						// Game loaded callback.
						if (GAME.map.callback)
						{
							GAME.debug("Executing map callback.");
							GAME.map.callback();
							delete GAME.map.callback;
						}
					}
				);
				return true;
			}
			else
			{
				GAME.debug("Downloading map: <strong>" + name + "</strong>");
				GAME.script("scripts/maps/" + name + (location.href.match(/gamingmedley\.com/) ? ".min" : "") + ".js");
			}
			return false;
		},
		maps: {},
		timeouts: {}
	},

	// message box
	message: function()
	{

		// If the message is loading, don't do anything.
		if (!$(".message").hasClass("hidden"))
		{

			$(".message").remove(); // GAME.$gamengine.remove(".message");

			// Message callback. If all messages completed, execute full callback.
			if (
				typeof(arguments[0]) == "undefined" &&
				typeof(GAME.data.messages[0]) == "undefined"
			)
			{
				GAME.doing.message = false;

				// If there is a callback,
				if (typeof(GAME.callbacks.message) == "function")
				{
					GAME.debug("Executing message callback.");
					GAME.callbacks.message();
				}
				return true;
			}

			// Set up messages if first call.
			if (arguments.length)
			{
				GAME.doing.message = true;

				var messages = arguments;
				if (typeof(messages[0]) == "object")
					messages = messages[0];

				// store all messages
				GAME.data.messages = [];
				GAME.data.messageId = (typeof(messages[0]) == "number" ? messages[0] : null);
				GAME.callbacks.message = null;
				for (var x = GAME.data.messageId != null ? 1 : 0; x < messages.length; x++)
				{
					if (typeof(messages[x]) == "function")
						GAME.callbacks.message = messages[x];
					else
						GAME.data.messages.push(messages[x]);
				}
				GAME.debug(
					"Created " + GAME.data.messages.length + " message" + (GAME.data.messages.length != 1 ? "s" : "") +
					(GAME.data.messageId != null ? " for character #" + GAME.data.messageId : "") +
					(typeof(GAME.callbacks.message) == "function" ? " with callback" : "") + "."
				);
			}

			var message = GAME.data.messages.shift();

			// the message element
			var $message = $('<div class="message"><div>' + message + '<\/div><\/div>')
				.css({
					//fontFamily: (typeof(message.font) == "string" ? message.font : ""),
					zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
				});

			// If a portrait will be added, hide the message until it has loaded.
			if (GAME.data.messageId != null)
				$message.addClass("hidden");

			// If someone is saying the message,
			if (GAME.data.messageId != null)
				$message.addClass(GAME.characters[GAME.data.messageId].character).css({
					backgroundColor: "#" + GAME.characters[GAME.data.messageId].background,
					borderColor: "#" + GAME.characters[GAME.data.messageId].foreground,
					color: "#" + GAME.characters[GAME.data.messageId].foreground
				});
			GAME.$gamengine.append($message);

			// Add the speaker's portrait to the message.
			if (GAME.data.messageId != null)
			{
				var portrait = GAME.url + "images/message/" + GAME.characters[GAME.data.messageId].character + "/" + GAME.characters[GAME.data.messageId].background + "-" + $message.height() + ".jpg";
				GAME.preloader.quick(
					portrait,
					function()
					{
						$message.css(
							"background-image",
							'url("' + portrait + '")'
						);
						$message.removeClass("hidden");
					}
				);
			}
			return true;
		}
		return false;
	},
	multiplayer: false,
	notice: function(str)
	{
		$("#notice").remove();
		GAME.debug("Notice: " + str);
		GAME.$notice = $('<div id="notice">' + str + '<\/div>').fadeTo(0, 0).boxShadow(12, 12, 12, "#202020");
		GAME.$gamengine.append(GAME.$notice);
		GAME.$notice.css({
			marginRight: "-" + GAME.$notice.outerWidth() + "px",
			zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
		});
		GAME.$notice.fadeTo(
			500, 1,
			function()
			{
				GAME.map.timeouts.notice = setTimeout(
					function()
					{
						// $("#notice") keeps fading even if it gets deleted and replaced with a different one
						// i.e. if you change the map mid-fade, the new notice will be removed.
						GAME.$notice.fadeTo(
							500, 0,
							function()
							{
								GAME.$notice.remove();
							}
						);
					},
					2000
				);
			}
		);
	},

	// percentage rounded to two decimal places
	percent: function(a, b)
	{
		return Math.round(a / b * 10000) / 100 + "%"
	},
	preload: function(callback)
	{
		GAME.doing.preload = true;

		var i = [],
			map = GAME.map.maps[GAME.map.current];

		/*
		for (var x = 0; x < arguments.length; x++)
		{
			if (typeof(arguments[x]) == "object")
			{
				for (var y = 0; y < arguments[x].length; y++)
					i.push(arguments[x][y]);
			}
			else
				i.push(arguments[x]);
		}
		*/

		i.push(GAME.url + "images/characters/" + GAME.timeOfDay(true) + "/" + GAME.characterSettings[GAME.characters[0].character].image);
		i.push("./images/preloader/round.gif");
		i.push("./images/preloader/bar.gif");
		i.push("./images/preloader/item.gif");
		//i.push(GAME.url + "images/say/corner/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");
		//i.push(GAME.url + "images/say/horizontal/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");
		//i.push(GAME.url + "images/say/stem/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");
		//i.push(GAME.url + "images/say/vertical/" + GAME.sayBG + "-" + GAME.sayFG + ".gif");

		// overlays
		if (typeof(map.overlays) == "object")
		{
			for (x = 0; x < map.overlays.length; x++)
			{
				if (typeof(map.overlays[x].image) == "string")
					i.push(GAME.url + "images/maps/" + GAME.timeOfDay(true) + "/" + map.overlays[x].image);
			}
		}

		// sound
		if (
			GAME.sound.supported &&
			typeof(map.sound) == "object"
		)
		{
			for (x = 0; x < map.sound.length; x++)
			{
				var id = map.sound[x].match(/\/?([\d\-\.\w]+?)\.(?:mid|mp3|ogg|wav)$/)[1];

				// don't download sounds already loaded
				if (!soundManager.getSoundById(id))
					i.push("./sound/" + map.sound[x]);
			}
		}

		// images in the map
		if (typeof(map.imgs) == "object")
		{
			for (x = 0; x < map.imgs.length; x++)
				i.push("./images/" + map.imgs[x]);
		}
		GAME.preloader.load(i, typeof(callback) == "function" ? callback : null);
	},
	preloader: {
		callback: null,
		checkpoint: 0,
		complete: function()
		{
			// GAME.debug("Preloading complete.");
			GAME.doing.preload = false;
			if (typeof(GAME.preloader.callback) == "function")
			{
				// GAME.debug("Executing preload callback.");
				GAME.preloader.callback();
			}
		},
		delay: 0,
		done: 0,
		faux: function()
		{
			var thus = (GAME.preloader.totalBytes / GAME.preloader.totalTime) * // bytes per second
					(new Date().getTime() - GAME.preloader.started); // seconds
			thus = Math.min(thus, GAME.preloader.thus + GAME.preloader.todo[GAME.preloader.done][1]);
			var percent = GAME.percent(thus, GAME.preloader.total);
			GAME.preloader.$bar2.width(percent);
			GAME.preloader.$percent.html(percent);
			GAME.preloader.$thus.html(GAME.format(Math.round(thus)));
			GAME.preloader.timeouts[1] = setTimeout(GAME.preloader.faux, 20);
		},
		init: function(todo)
		{
			GAME.preloader.todo = todo;
			GAME.preloader.started = new Date().getTime();
			GAME.preloader.checkpoint = GAME.preloader.started;
			for (var x = 0; x < GAME.preloader.todo.length; x++)
				GAME.preloader.total += GAME.preloader.todo[x][1];
			GAME.preloader.$total.html("<span>0</span> / " + GAME.format(GAME.preloader.total));
			GAME.preloader.$thus = GAME.preloader.$total.children("span").first();
			GAME.preloader.next();
		},
		load: function(a, callback)
		{
			// GAME.debug("Preloading...");
			GAME.doing.preload = true;
			if (typeof(callback) == "function")
				GAME.preloader.callback = callback;
			else
				GAME.preloader.callback = null;
			var b = [];

			// Don't preload items that we've loaded this session.
			for (var x = 0; x < a.length; x++)
			{
				if (!GAME.preloader.past.contains(a[x]))
					b.push(a[x]);
			}
			if (b.length)
			{
				GAME.preloader.done = 0;
				GAME.preloader.thus = 0;
				GAME.preloader.total = 0;
				GAME.$gamengine.append(
					'<div id="preloader">' +
						'<div id="preloader-area"><\/div>' +
						'<div id="preloader-bar1">' +
							'<div id="preloader-bar2"><\/div>' +
						'<\/div>' +
						'<div id="preloader-round"><\/div>' +
						'<div id="preloader-items"><\/div>' +
						'<div id="preloader-total">Loading...<\/div>' +
						'<div id="preloader-percent">0%<\/div>' +
					'<\/div>'
				);
				GAME.$preloader = $("#preloader");
				GAME.preloader.$area = $("#preloader-area");
				GAME.preloader.$bar1 = $("#preloader-bar1");
				GAME.preloader.$bar2 = $("#preloader-bar2");
				GAME.preloader.$items = $("#preloader-items");
				GAME.preloader.$percent = $("#preloader-percent");
				GAME.preloader.$total = $("#preloader-total");
				for (var x = 0; x < b.length; x++)
					GAME.preloader.$items.append('<div class="preloader-item loading"><\/div>');
				GAME.preloader.scroll();
				GAME.script("scripts/filesize.php?files=" + b.join(","));
			}
			else
				GAME.preloader.complete();
		},
		loaded: function()
		{
			var finished = new Date().getTime();
			GAME.preloader.totalBytes += GAME.preloader.todo[GAME.preloader.done][1];
			GAME.preloader.totalTime += finished - GAME.preloader.checkpoint;
			GAME.preloader.past.pushUnique(GAME.preloader.todo[GAME.preloader.done][0]);
			GAME.preloader.done++;
			GAME.preloader.checkpoint = finished;

			// start the faux progress bar after the first download
			if (GAME.preloader.done == 1)
				GAME.preloader.faux();
			GAME.preloader.thus += GAME.preloader.todo[GAME.preloader.done - 1][1];
			GAME.preloader.$thus.html(GAME.format(GAME.preloader.thus));
			GAME.preloader.$items.children(".loading:first").removeClass("loading").addClass("loaded");
			var percent = GAME.percent(GAME.preloader.thus, GAME.preloader.total);
			GAME.preloader.$bar2.width(percent);
			GAME.preloader.$percent.html(percent);
			if (GAME.preloader.done == GAME.preloader.todo.length)
			{
				clearTimeout(GAME.preloader.timeouts[0]); // progress bar animation
				clearTimeout(GAME.preloader.timeouts[1]); // faux progress
				GAME.$preloader.remove();
				GAME.preloader.complete();
			}
			else
			{
				GAME.preloader.$bar2.css("max-width", GAME.percent(GAME.preloader.thus + GAME.preloader.todo[GAME.preloader.done][1], GAME.preloader.total));
				setTimeout(GAME.preloader.next, GAME.preloader.delay);
			}
		},
		next: function()
		{
			var src = GAME.preloader.todo[GAME.preloader.done][0];
			if (id = src.match(/\/([\d\-\.\w]+?)\.(?:mid|mp3|ogg|wav)$/))
			{
				GAME.debug("Loading sound: " + src);
				if (
					GAME.sound.supported &&
					!soundManager.getSoundById(id[1]) // don't redownload sounds already loaded
				)
				{

					// If there is an author, add them to the list of authors to be displayed via notice
					if (author = src.match(/\/by\/([\d\-\.\w]+)\/[\d\-\.\w]+\.(?:mid|mp3|ogg|wav)$/))
						GAME.sound.authors[id[1]] = author[1];
					var temp = soundManager.createSound({
						id: id[1],
						url: src,
						autoLoad: true,
						autoPlay: false,
						onfinish: function()
						{
							if (this.loop)
								GAME.sound.play(this.sID, true);
						},
						onload: GAME.preloader.loaded,
						volume: GAME.sound.volumeLevel
					});
					temp.loop = true;
				}
				else
					GAME.preloader.loaded();
			}
			else
			{
				GAME.debug('Loading image: <a href="' + src + '">' + src.replace(new RegExp("^" + GAME.url.replace(/\./g, "\\.").replace(/\//g, "\\/")), "./") + '<\/a>');
				var img = document.createElement("img");
				img.onload = GAME.preloader.loaded;
				img.setAttribute("src", src);
				GAME.preloader.$area.append(img);
			}
		},
		past: [],
		quick: function()
		{
			// GAME.debug("Starting quick preloader.");
			GAME.preloader.todo = [];
			var callback = null;
			for (var x = 0; x < arguments.length; x++)
			{
				if (typeof(arguments[x]) == "function")
					callback = arguments[x];
				else if (!GAME.preloader.past.contains(arguments[x]))
					GAME.preloader.todo.push(arguments[x]);
			}

			// Set here instead of for loop, because it must be set (even to null) in order to override any potential pre-existing callbacks.
			// Can't erase callback after calling it, because the called callback may set a new one (such as the map preload character creation callback containing a say box quick load).
			// Erasing the callback post-execution in this case would just erase the new callback before it has a chance to be called.
			GAME.preloader.callback = callback;
			if (GAME.preloader.todo.length)
			{
				GAME.doing.preload = true;
				GAME.preloader.quickTotal = 0;
				GAME.$gamengine.append(
					'<div id="preloader-area"><\/div>' +
					'<img alt="Loading..." height="16" id="preloader-quick" src="./images/preloader/quick7.gif" width="16" />'
				);
				GAME.preloader.$area = $("#preloader-area");
				GAME.preloader.$quick = $("#preloader-quick")
					.css({zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000})
					.slide(GAME.$gamengine.width() / 2 - 8, GAME.$gamengine.height() / 2 - 8);
				for (var x = 0; x < GAME.preloader.todo.length; x++)
				{
					// needs quick loading sound, too
					GAME.debug('Quick loading image: <a href="' + GAME.preloader.todo[x] + '">' + GAME.preloader.todo[x].replace(new RegExp("^" + GAME.url.replace(/\./g, "\\.").replace(/\//g, "\\/")), "./") + '<\/a>');
					var img = document.createElement("img");
					img.onload = GAME.preloader.quickLoaded;
					img.setAttribute("src", GAME.preloader.todo[x]);
					GAME.preloader.$area.append(img);
				}
			}
			else
				GAME.preloader.complete();
		},
		quickLoaded: function()
		{
			GAME.preloader.past.push(GAME.preloader.todo[GAME.preloader.quickTotal]);
			GAME.preloader.quickTotal++;
			if (GAME.preloader.quickTotal == GAME.preloader.todo.length)
			{
				//setTimeout(function(){
				GAME.preloader.$area.remove();
				GAME.preloader.$quick.remove();
				GAME.preloader.complete();
				//},2500);
			}
		},
		quickTotal: 0,
		scroll: function()
		{
			GAME.preloader.$bar1.scroll(2, 0);
			GAME.preloader.$bar2.scroll(2, 0);
			GAME.preloader.timeouts[0] = setTimeout(
				GAME.preloader.scroll,
				100
			);
		},
		started: 0,
		thus: 0,
		timeouts: [0, 0],
		todo: [],
		total: 0,
		totalBytes: 0,
		totalTime: 0
	},
	random: function(min, max)
	{
		if (typeof(max) == "undefined")
		{
			max = min;
			min = 0;
		}
		return Math.floor(Math.random() * (max - min + 1)) + min;
	},
	say: function(id, message, offset)
	{
		// No interrupting!
		if (GAME.is("choice", "message"))
			return setTimeout(
				function()
				{
					GAME.say(id, message, offset);
				},
				100
			);

		$(".say-" + id).remove();
		if (typeof(message[offset * 2]) == "string")
		{
			GAME.preloader.quick(
				GAME.url + "images/say/corner/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
				GAME.url + "images/say/horizontal/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
				GAME.url + "images/say/stem/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
				GAME.url + "images/say/vertical/" + GAME.characters[id].background + "-" + GAME.characters[id].foreground + ".gif",
				function()
				{
					var stem = id == 0 || GAME.characters[0].position[0] < GAME.characters[id].position[0] ? "left" : "right";
					GAME.$gamengine.append(
						'<div class="say say-' + id + '">' +
							'<div class="horizontal top"><\/div>' +
							'<span class="text">' + message[offset * 2] + '<\/span>' +
							'<div class="vertical left"><\/div>' +
							'<div class="vertical right"><\/div>' +
							'<div class="horizontal bottom"><\/div>' +
							'<div class="corner one"><\/div>' +
							'<div class="corner two"><\/div>' +
							'<div class="corner three"><\/div>' +
							'<div class="corner four"><\/div>' +
							'<div class="stem ' + stem + '"><\/div>' +
						'<\/div>'
					);
					var $say = $(".say-" + id);
					var $sayText = $say.children(".text");
					// Pythagorean Theorum (a^2 + b^2 = c^2; c = SqRt(a^2 + b^2)
					// distance between the two characters = square root of horizontal difference squared plus vertical difference squared
					var a = GAME.characters[1].position[0] - GAME.characters[0].position[0],
						b = GAME.characters[1].position[1] - GAME.characters[0].position[1],
						c = Math.round(GAME.$gamengine.width() / GAME.map.maps[GAME.map.current].block),
						d = Math.round(GAME.$gamengine.height() / GAME.map.maps[GAME.map.current].block);
					$sayText.css(
						"font-size",
						(14 - Math.round(Math.sqrt(a * a + b * b) / Math.round(Math.sqrt(c * c + d * d)) * 10)) + "px"
					);
					$say.children(".horizontal").width($sayText.width() - 1);
					$say.children(".vertical").height($sayText.height() - 1);
					//$say.children(".vertical.right").slide($sayText.width() + 6, 0);
					$say.css({
						left: (

							// center of the screen
							320 +

							// number of blocks away from the player
							(GAME.characters[id].position[0] - GAME.characters[0].position[0]) * GAME.map.maps[GAME.map.current].block +

							// player's offset (when walking)
							GAME.characters[0].offset[0] +

							// character's offset (when walking)
							GAME.characters[id].offset[0] -

							// half the text box
							($sayText.width() + 11) / 2 +

							// Move stem to side of player.
							(stem == "left" ? -1 : 1) * GAME.characters[id].width
						).toString() + "px",
						marginBottom: "-" + ($sayText.height() + 12).toString() + "px",
						top: (

							// center of the screen
							(240 - Math.round(GAME.characters[id].height / 2) + GAME.characters[id].offset[1]) +

							// offset for non-players by the number of blocks away from the player
							(id == 0 ? 0 : (GAME.characters[id].position[1] - GAME.characters[0].position[1]) * GAME.map.maps[GAME.map.current].block) +

							// offset for walking player
							GAME.characters[0].offset[1] -

							// offset by height of text box
							$sayText.height() - 37
						).toString() + "px",
						zIndex: GAME.map.maps[GAME.map.current].overlays.length * 1000
					}).height($sayText.height() + 11).width($sayText.width() + 11);

					// offset by half textbox and stem
					$say.children(".stem").css("left", ($say.width() / 2 - (stem == "left" ? 11 : GAME.characters[id].width / 2)) + "px");
					$sayText.css({
						backgroundColor: "#" + GAME.characters[id].background,
						color: "#" + GAME.characters[id].foreground
					});
					var shapes = ["corner", "horizontal", "stem", "vertical"];
					for (var x = 0; x < 4; x++)
						$(".say ." + shapes[x]).css("background-image", 'url("' + GAME.url + 'images/say/' + shapes[x] + '/' + GAME.characters[id].background + '-' + GAME.characters[id].foreground + '.gif")');
					if (typeof(message[offset * 2 + 1]) == "number")
						GAME.characters[id].timeouts.say = setTimeout(
							function()
							{
								GAME.say(id, message, offset + 1);
							},
							message[offset * 2 + 1]
						);
				}
			);
		}
		else if (typeof(message[offset * 2]) == "function")
		{
			GAME.debug("Executing say callback.");
			message[offset * 2]();
		}
	},
	script: function(url, id)
	{
		GAME.debug('<a href="' + GAME.url + url + '">' + url + '<\/a>');
		if (
			typeof(id) == "string" &&
			document.getElementById(id)
		)
			GAME.$head.remove("#" + id);
		var temp = document.createElement("script");
		temp.setAttribute("src", GAME.url + url);
		temp.setAttribute("type", "text/javascript");
		temp.onload = function()
		{
			GAME.$head.remove(this);
		};
		GAME.$head.append(temp);
	},
	settings: {},
	sound: {
		authors: {},

		// Calling this crashes everything.
		destroy: function()
		{
			while (soundManager.soundIDs.length)
			{
				GAME.debug("Destroying sound: " + soundManager.soundIDs[0]);
				soundManager.destroySound(soundManager.soundIDs[0]);
			}
		},
		enabled: false,
		mute: function()
		{
			if (GAME.sound.supported)
			{
				GAME.sound.enabled = false;
				soundManager.mute();
				GAME.debug("Muted.");
			}
		},
		play: function(id, loop)
		{
			if (
				GAME.sound.supported &&
				soundManager.getSoundById(id).playState != 1
			)
			{
				soundManager.play(id);
				if (typeof(loop) != "undefined")
				{
					if (
						!loop &&
						soundManager.getSoundById(id)
					)
						soundManager.getSoundById(id).loop = false;
				}

				// only debug music that loops (not sound effects) and only on the first play
				else
				{
					GAME.debug("Playing " + id);
					if (id in GAME.sound.authors)
						GAME.preloader.quick(
							"./images/notice/music/000000.gif",
							function()
							{
								GAME.notice(
									'<img alt="Music" height="12" src="./images/notice/music/000000.gif" width="13" /> &nbsp; ' +
									'&quot;' + id.replace(/\_/g, " ") + '&quot; by ' + GAME.sound.authors[id].replace(/\_/g, " ")
								);
							}
						);
				}
			}
		},
		ready: function()
		{
			GAME.debug("Sound Manager loaded.");
			GAME.sound.enabled = true;
			GAME.sound.supported = true;
			GAME.debug("Engine starting.");
			GAME.start();
		},
		stop: function()
		{
			for (var x = 0; x < soundManager.soundIDs.length; x++)
				soundManager.getSoundById(soundManager.soundIDs[x]).stop();
		},
		supported: false,
		timeout: function()
		{
			GAME.debug('<strong class="error">Error loading Sound Manager.</strong>');
			GAME.sound.enabled = false;
			GAME.sound.supported = false;
			GAME.start();
		},
		unmute: function()
		{
			if (GAME.sound.supported)
			{
				GAME.sound.enabled = true;
				soundManager.unmute();
				GAME.debug("Unmuted.");
			}
		},
		volume: function(x)
		{
			var temp = GAME.sound.volumeLevel;
			GAME.sound.volumeLevel += x;
			GAME.sound.volumeLevel = Math.min(Math.max(GAME.sound.volumeLevel, 0), 100);
			if (GAME.sound.volumeLevel != temp)
			{
				GAME.debug((x < 0 ? "De" : "In") + "creasing volume to " + GAME.sound.volumeLevel + "%.");
				for (var x = 0; x < soundManager.soundIDs.length; x++)
					soundManager.setVolume(soundManager.soundIDs[x], GAME.sound.volumeLevel);
			}
		},
		volumeLevel: 100
	},
	start: null,
	timeOfDay: function(numeric)
	{
		if (typeof(numeric) == "undefined")
			var numeric = false;
		var hour = new Date().getHours();
		// night (12, 1, 2, 3) -> dawn (4, 5, 6, 7) -> day (8, 9, 10, 11, 12, 1, 2, 3) -> evening (4, 5, 6, 7) -> night (8, 9, 10, 11)
		return (
			hour >= 4 &&
			hour < 8 ?
			numeric ? 66 : 'dawn' :
			hour >= 8 &&
			hour < 16 ?
			numeric ? 75 : 'day' :
			hour >= 16 &&
			hour < 20 ?
			numeric ? 66 : 'dusk' :
			numeric ? 33 : 'night'
		);
	},
	timeouts: {},
	url: (location.href.match(/^file\:\/\/\/C\:\/Websites\//) ? location.href.replace(/^file\:\/\/\/C\:\/Websites\//, "http://127.0.0.1/").match(/(.*)\/[\-\w]*/)[1] : ".") + "/"
};

GAME.start = function()
{
	GAME.load({
		character: {
			character: "Red",
			facing: 3,
			name: "Charles Stover",
			position: [2, 6]
			// pallet: [16, 14]
			// room1: [2, 6]
		},
		map: "room1",
		multiplayer: true
	});
}

window["soundManager"]["debugMode"] = false;
window["soundManager"]["flashVersion"] = 8;
window["soundManager"]["onready"](GAME.sound.ready);
window["soundManager"]["ontimeout"](GAME.sound.timeout);
window["soundManager"]["url"] = "./scripts/";
window["soundManager"]["useFlashBlock"] = false;